\documentclass[twoside]{report}
\usepackage[cp1251]{inputenc}
\usepackage[english,russian]{babel}
\usepackage[T2A]{fontenc}
\usepackage{spbstuthesis}
\usepackage{graphicx}
\usepackage{multirow}
\usepackage{amsmath}
\usepackage{subfigure}
\usepackage{appendix}
\usepackage{xcolor}
\usepackage{listings}

\usepackage{amsfonts}

\bachelor{Разработка и реализация языка описания сценариев тестирования автомобильных систем}{09.03.01<<Информатика и вычислительная техника>>}{09.03.01\_06<<Распределенные информационные системы>>}{43504/6}{А. А. Спасеева}{к.т.н., доцент}{ А. В. Самочадин}



\Abstract{Выпускная квалификационная работа посвящена разработке языка описания сценариев тестирования автомобильных систем. Проводится сравнительный анализ схожих по тематике инструментов.

Так же описываются принципы разработки языков и технических инструментов, выбранных для разработки.

Результат работы -- язык описания сценариев тестирования автомобильных систем, являющийся потенциально пригодным для внедрения на производстве.
%для бакалаврских, дипломных и магистерских работ

Ключевые слова: Предметно-ориентированный язык, функциональное тестирование, автомобильные системы.

}{Final year graduation diploma dedicated to the development of the language designed for describing various automobile system testing scenarios. The comparable analysis of systems that share similar instruments is conducted.

Furthermore, this paper aims to describe the development of the programming languages as well as technical instruments used by them.

The final result of this work is a fully functional language used for describing automobile testing scenarios. Also, this language could potentially be integrated into the corporate environment.

Keywords: domain specific language, functional testing, automobile systems.
}


\begin{document}
 
\sloppy
\maketitle
\task{A. A. Спасеевой}{
%для бакалаврских, дипломных и магистерских работ
\item Срок сдачи работы.
\item Исходные данные к проекту (работе).
\item Содержание расчетно-пояснительной записки (перечень подлежащих 
разработке вопросов).
\item Перечень графического материала с точным указанием обязательных 
чертежей.
\item Консультанты по проекту (с указанием относящегося к ним разделов 
проекта, работы).
}
%для бакалаврских, дипломных и магистерских работ
\makeabstract
\tableofcontents



%для бакалаврских, дипломных и магистерских работ
\Chapter{Список обозначений}
\begin{tabular}{ll}
UML& Унифицированный язык моделирования\\
ECU&Electronic Control Unit\\
BDD& Behaviour-driven development\\
ПО & Программное обеспечение\\
TTD&Test-driven development\\
DSL& Domain-specific language\\
AUTOSAR&Automotive Open System Architecture\\
БНФ&Форма Бэкуса-Наура\\
РБНФ&Расширенная форма Бэкуса-Наура\\
AST& Abstract syntax tree\\
АС&Автомобильные системы
\end{tabular}

%------------------------ВВЕДЕНИЕ-----------------------------
\Chapter{Введение}
С развитием автомобильной промышленности тестирование автомобильных систем стало неотъемлемой частью жизненного цикла разработки программного и аппаратного обеспечения транспортных средств. Современные автомобили включают множество встроенных систем для повышения уровня безопасности и комфорта водителей и пассажиров путем обеспечения функций, таких как адаптивный круиз-контроль, контроль давления в шине и др.

Современные автомобили имеют несколько блоков управления (electronic control unit, ECU), связанных между собой внутри машинной сетью. Эти блоки взаимодействуют между собой через стандартные шинные архитектуры CAN, FlexRay, LIN и Ethernet. С развитием техники количество ECU в автомобильных системах стремительно растет, что приводит к созданию сложных структур сетей. К основным особенностям автомобильного программного обеспечения можно отнести:
\begin{itemize}
\item    надежность: в сложной сети ECU в течение всего срока эксплуатации автомобиля автомобильные программные системы должны работать исключительно надежно;
\itemфункциональная безопасность: такие функции, как анти блокировочная тормозная система, требуют безотказной работы, что определяет высокие требования к процессам разработки программного обеспечения и к самим программам;
\itemработа в режиме реального времени: быстрая реакция (от микросекунд до миллисекунд) на внешние события требует оптимизированных операционных систем и особой программной архитектуры;
\itemминимальное потребление ресурсов: любое дополнение вычислительных ресурсов или памяти увеличивает стоимость продуктов, что при миллионных тиражах выливается в немалые деньги;
\itemнадежная архитектура: автомобильное программное обеспечение должно выдерживать искажение сигналов и поддерживать электромагнитную совместимость;
\end{itemize}
Функциональные проверки безопасности автомобильных систем на программном уровне включают:
\begin{itemize}
\itemФункциональное тестирование, целью которого является предоставление гарантий, что ПО удовлетворяет требованиям высокого и низкого уровней.
\itemАнализ времени выполнения худшего сценария, для того, чтобы гарантировать, что критические функции ПО выполняются достаточно быстро (такие как срабатывание подушек безопасности).
\itemСтруктурный анализ покрытия.
\end{itemize}


Что касается тестирования автомобильных систем, необходимо хорошо понимать, как устроен автомобиль в целом и его составляющие по отдельности. Однако представления о системе у инженеров и менеджеров зачастую очень сильно расходятся. Взаимодействие участников бизнес процесса, а именно заказчика, бизнес-аналитика, менеджера, разработчика и тестировщика, является неотъемлемой частью гибкой методологии разработки ПО (Agile software development).

В данной работе рассматривается разработка языка для функционального тестирования ПО автомобильных систем для того, чтобы описываемые на нем тестовые сценарии были понятны всем участникам бизнес цикла.
Практика «разработка через поведение» (behaviour-driven development, BDD) была создана для достижения взаимопонимания между всеми участниками процесса. В сфере автомобильных систем BDD подход сильно облегчать процесс разработки.


Данная работа организована следующим образом. В главе \ref{cReview} представлен
обзор проблемы создания языка для описания тестовых сценариев тестирования автомобильных систем и обзор аналогов. Глава \ref{cDesign} содержит
описание предлагаемого подхода к непосредственному построению языка. Вопросы его практической
реализации рассмотрены в главе \ref{cImplementation}. Результаты
экспериментального исследования его эффективности приведены в главе
\ref{cExperiments}.

%------------Постановка задачи и обзор литературы -------------------
\chapter{Обзор литературы и постановка задачи }
\label{cReview}
%Рекомендуемый объем главы "--- 10--15 стр.
%Название главы должно отражать ее содержание, например  Проблема вечного
%двигателя''.

%---------------------------ГЛАВА 1.1 ЦЕЛЬ И ЗАДАЧИ
\section{Цель и задачи} Целью выпускной квалификационной работы является разработка проблемно-ориентированного языка для функционального тестирования автомобильных систем, который облегчит взаимодействие между тестировщиком, заказчиком, менеджером, аналитиками, разработчиками и предоставит функционал, необходимый для симуляции работы автомобильных сетей. Такой язык позволит достичь большего взаимопонимания между менеджерами, аналитиками и инженерами, что в свою очередь значительно упростит разработку ПО и повысит качество разрабатываемого продукта.
Для достижения поставленной цели следует выполнить ряд задач.
\begin{itemize}
\itemИсследовать предметную область.
\itemВыделить аналоги и сравнить аналоги существующих инструментов для тестирования, позволяющих проверить качество программного обесчечения автомобильной системы.
\itemРазработать проблемно-ориентированный язык для написания тестовых сценариев.
\itemРеализовать язык.
\itemПротестировать реализацю языка, а так же изучить такие аспекты языка, как удобство использования языка и эффективность разработки и сопровождения тестовых сценариев, разрабатываемых на этом языке.
\end{itemize}


%---------------------------ГЛАВА 1.2. Обзор литературы
\section{Обзор литературы}


Современный автомобиль обладает огромным количеством компьютеров, которые общаются между собой на разных скоростях и типах коммуникаций, так как призваны выполнять разные задачи. С очень быстрым внедрением электронных встроенных систем в транспортных средствах отслеживание различных параметров транспортного средства и их управление стали необходимостью. Таким образом были разработаны диагностические системы, чтобы клиенты (проектировщики, тестировщики и механики) могли обнаружить ошибки в транспортном средстве, с помощью соединения их диагностического оборудования c электронным блоком управления в транспортном средстве.
% Компьютерная диагностика автомобиля -- это диагностика различных систем автомобиля, производящаяся его блоком управления.

Бортовые системы современного автомобиля оборудованы электронным блоком управления с функцией само диагностики, анализирующим основные системы автомобиля и оповещающим водителя об их неисправности.
Для компьютерной диагностики электронный блок управления на физическом уровне через специализированные диагностические интерфейсы подключается к стенду, оснащенному датчиками, посредством которых данные о работе систем передаются для дальнейшего анализа на компьютер. На этом этапе активируется управляющее устройство для сбора информации.

Одним из направлений в автомобильном тестировании является диагностика транспортных средств, описанная в серии стандартов UDS ISO 14229\cite{stUds}.
Unified Diagnostic Service (UDS) - автомобильный протокол, который позволяет диагностическим системам общаться с ECU, чтобы диагностировать ошибки и при необходимости повторно программировать ECU. Потребность в стандарте возникла, так как производители транспортных средств собирают автомобильные компоненты у разных поставщиков. До возникновения UDS ISO 14229 поставщики должны были заниматься проблемами совместимости между различными диагностическими протоколами, сейчас же все ECU разрабатываются, придерживаясь данного стандарта. Архитектура UDS протокола разработана на основе сетевой модели OSI (Open System Interconnection) и реализует пятый (сетевой уровень) и седьмой (прикладной уровень) модели.

Стек протокола UDS предлагает четыре важных категории сервисов:
\begin{itemize}
\itemЗагрузка данных в ECU для разрешения программных ошибок или добавления вновь разработанных программных модулей;
\itemУдаленная активация рутин. Диагностика транспортного средства может потребовать тестирования некорректного компонента в определенном  диапазоне значений.  Более того во время тестирования некоторые шаги могут выполняться в течении определенного времени. Для такого рода активностей используется Remote Routine Service, описанный в ISO 14229.
\itemВозможность передачи данных позволяет клиентам читать или записывать данные в ECU. Данные могут быть считаны или записаны в ячейки памяти, имеющие 16-битный адрес. Информация может быть статичной (например серийный номер устройства) и динамической (например скорость мотора или показатели сенсоров). Допустимые значения данных и их длина могут варьироваться в зависимости от адреса ячейки памяти.
\itemДиагностика ошибок. Это один из самых важных сервисов UDS протокола. Когда в ECU возникает ошибка, DTC (Diagnostic trouble code), соответствующий возникшей ошибке  сохраняется в определенной области памяти, называемой FCM (Faut Code Memory). Каждая ошибка имеет одно или несколько условий возникновения, обычно описываемые в требованиях.
\end{itemize}


Одно и то же оборудование, разрабатываемое для разных автомобильных компаний с различной внутренней архитектурой программного обеспечения при тестировании ПО может рассматриваться в качестве «черного ящика». Данное понятие предложил У.Р. Эшби в своей книге «Введение в кибернетику». Под черным ящиком подразумевается объект исследования, внутреннее устройство которого неизвестно. В кибернетических системах оно помогает изучать поведение систем, абстрагируясь от их внутреннего устройства. Такое тестирование называется поведенческим. В этом случае проверяется функциональное поведение объекта с точки зрения внешнего мира. Под этой стратегией понимается создание тестов для тестового набора, основанных на технических требованиях и их спецификациях. Фактически, при поведенческом тестировании известно какой результат должен быть при определенном наборе данных, которые подаются на вход. Проанализировав требования и спецификации тестировщик может легко определить набор тестовых сценариев для проверки различной функциональности тестируемой системы. Принимая тестируемую систему в качестве черного ящика ее можно исследовать, манипулируя входными данными и данными, полученными на выходе. Чтобы лучше понять, как исследуется поведение  черного ящика'', предположим что имеется некоторая система управления, внутреннее устройство которой неизвестно для пользователя. Эта система управления имеет входы $X(x_1, x_2, ..., x_n)$ и выходы $Y(y_1, y_2, ..., y_n)$. Способ исследования поведения данной системы заключается в том, что выходы системы зависят от входов системы и времени $t_k, k \in \mathbb{Z}$. При этом величины времени выбираются произвольно (рис. \ref{fblackbox}) .

\begin{Figure}{Исследование поведения черного ящика''}{fblackbox}
{\includegraphics[width=\linewidth]{res/blackBox}}
\label{fig:image}
\end{Figure}

В марте 2006 года Д. Норт предложил методологию BDD (behaviour-driven development), основанную на гибкой методологии разработки. BDD является своего рода расширением техники разработки программного обеспечения через тестирование (test-driven development, TDD). Идея BDD подхода была в том, что в процессе написания требования для разрабатываемого ПО аналитики должны описать тестовые сценарии таким образом, чтобы их смог понять и разработчик, и тестировщик, и заказчик. При этом тестовые сценарии состоят из набора заранее обговоренных предложений.
В своей статье Dan North описал следующие BDD идеи:

\begin{itemize}
\itemНазвание тестового метода должно быть предложением. В этом случае хорошо разработанная документация будет понятна и бизнес пользователям и инженерам.
\itemПростой шаблон делает тестовые методы более определенными.
\itemВыразительное название очень помогает, когда тест обрушился.
\itemСлово «поведение» более полезное, чем «тест».
\itemМетодология BDD предоставляет «общий язык» для анализа.
\itemПриемочные критерии должны быть выполняемыми.
\end{itemize}

Почти в то же время Эрик Эванс опубликовал книгу «Проблемно-ориентированное проектирование», в которой описал набор принципов и схем, направленных на создание оптимальных систем объектов. Его идея заключается в том, что для бизнеса удобно смоделировать систему, в которой будет определен единый язык (Domain specific language), основанный на бизнес области, такой, что бизнес словарь смогут использовать как менеджеры так и инженеры.

Совместно Эрик Эванс и Dan North разработали шаблон для выявления приемочных критериев теста. Они разработали структуры тестовых сценариев, в которых каждый шаг определялся ключевым словом
\begin{itemize}
\item    Given – дано начальное условие
\item    When – происходит событие
\item    Then – проверка, что получены некоторые результаты
\end{itemize}

На основе вышеперечисленных принципов BDD был создан язык Gherkin – человеко-читаемый язык, используемый для описания поведения системы.

С точки зрения автомобильной индустрии, в которых функциональное тестирование ПО подразумевает достаточно нетривиальную задачу данный подход сильно облегчает взаимодействие между всеми бизнес участниками. Однако не существует инструмента облегчающего разработку документации, а как следствия взаимопонимания между менеджерами и инженерами и, в то же время, учитывающего особенности данной сферы.

Возможность использовать единую всеми участниками модель предметной области позволяет значительно ускорить процесс проектирования ПО. Предметно-ориентированое программирование (Domain-driven design, DDD) основано на трех главных определениях:
\begin{itemize}
\itemОбласть (англ. domain, домен) — предметная область, к которой применяется разрабатываемое программное обеспечение.
\itemМодель (англ. model) — описывает отдельные аспекты области и может быть использована для решения проблемы.
\itemЯзык описания — используется для единого стиля описания домена и модели.
\end{itemize}

Использование концепции моделирования системы с использованием единого языка, основанного на бизнес области таким образом, что словарь используется в разработке ПО может решить проблему взаимодействия участников бизнес процесса.

В 2003 году была создана Автомобильная Открытая Системная Архитектура (AUTOSAR, Automotive Open System Architecture). Это открытая архитектура, которая стандартизирует архитектуры ПО для автомобильных ECU и жизненный цикл разработки.  Сегодня в Autosar входят более 150 компаний, и в рамках этого партнерства разрабатывается архитектура ECU, базовое программное обеспечение, методология и стандартизованные интерфейсы для прикладного программного обеспечения.

Учитывая, что все системы стандартизированы, одну и ту же систему (например, лидары для автомобилей марок Diamler и Audi) можно протестировать использую одни и те же инструменты. Однако, среди современных средств для тестирования программных систем нет специализированных под специфические нужды автомобильной промышленности, и при этом позволяющих разрабатывать спецификации на человеко-читаемом языке для реализации BDD подхода.


С расширением областей применения вычислительной техники возникла необходимость в новых — проблемно-ориентированном языке (domain-specific language, DSL), позволяющем в определенной области использовать специфичные обозначения и термины. Такие языки обеспечивают пользователям возможность коротко и четко сформулировать задачу и получить результаты в необходимой для них форме.


Хорошо разработанный DSL язык должен быть основан на следующих принципах (Debasish, G. 2011 DSLs in Action, Manning Publications):
\begin{itemize}
\itemЯзык зеркально отображает артефакты предметной области.
\itemЯзык должен использовать общий словарь предметной области. Словарь становится катализатором для лучшей связи между разработчиками и бизнес-пользователями.
\itemИмплементация языка должна быть абстракцией. В язык не должно быть точных фрагментов имплементации языка.
\end{itemize}

Использование проблемно-ориентированный языка позволит решить проблему разработки тестовой документации понятной всем участникам бизнес процесса с учетом специфики автомобильной промышленности.

%----------------------------------------ГЛАВА 1.3. Анализ существующих инструментов для тестирования
\section{Анализ существующих инструментов для тестирования}
%Описание реального объекта исследования, используемых методов исследования,
%техническое и организационное содержание работ.
%----------------------------------------------------1.3.1. Выделение критериев сравнения
\subsection{Выделение критериев сравнения}
Требования к разрабатываемой системе
\begin{itemize}
\itemАрхитектура тестов, разрабатываемых с помощью языка, должна быть событийно-управляемая (Event based).
\itemЯзык должен быть проблемно-ориентированным
\itemЯзык должен позволять использовать BDD подход.
\end{itemize}

\subsection{Обзор аналогов}

\begin{itemize}
\item CAPL (Communication Access Programming Language)

Компания Vector, разрабатывающая программные инструменты для работы с коммуникационными сетями, основывающихся на шинах CAN, LIN, FlexRay, Ethernet и др., используемыми в автомобильной промышленности создала программный пакет для разработчиков: CANoe. Этот инструмент поддерживает симуляцию работы сетей, предоставляет диагностические инструменты и т.д. Данный пакет используется большинством OEM-производителей и поставщиков автомобильных компонентов. В среде CANoe есть возможность разрабатывать тестовые сценарии на языке CAPL (Communication Access Programming Language).
\begin{Figure}[h!]{Тестовая спецификация CAPL}{fcapl}
{\includegraphics[width=\linewidth]{res/Capl}}
\label{fig:image}
\end{Figure}
CAPL - процедурный язык, на котором выполнение блоков программы управляются событиями. Эти блоки программы упоминаются как событие процедуры.

С помощью CAPL можно описать тесты, полностью покрывающие функциональные требования АС. Однако данный язык является Си подобным, достаточно трудным для понимания менеджерами и аналитиками.

\item CCDL

Еще одним языком для описания тестовых спецификаций в автомобильной сфере является CCDL. Это язык тестовых спецификаций для тестирования, основанном на требованиях. Предоставляет высокоуровневый язык тестирования. CCDL может использоваться для автоматизированного black box тестирования. Однако, спецификации содержат в себе программный код, непонятный для части бизнес участников (рис. \ref{fccdl}).

\begin{Figure}[h!]{Тестовый сценарий на языке CCDL}{fccdl}
{\includegraphics[width=\linewidth]{res/CAPL-EX}}
\label{fig:image}
\end{Figure}

\item Cucumber

\begin{Figure}[h!]{Тестовая спецификация Cucumber}{fcucumber1}
{\includegraphics[width=\linewidth]{res/CUCUMBER-EX-1}}
\label{fig:image}
\end{Figure}

Cucumber – это фреймворк, реализующий подход BDD. В Cucumber для разработки тестов используется Gherkin-нотация. Она определяет набор ключевых слов и структуру теста. Пример тестового сценария, написанного с помощью Cucumber приведена на рис. \ref{fcucumber1} Программная реализация шагов отделена от теста (рис. \ref{fcucumber2}), что очень удобно для бизнеса. Однако для создания полной domain specific модели АС необходимо каждый раз заново реализовывать протокол коммуникации с тестовым оборудованием.


\begin{Figure}[h!]{Реализация шага Cucumber}{fcucumber2}
{\includegraphics[width=\linewidth]{res/CUCUMBER-EX-2}}
\label{fig:image}
\end{Figure}


\end{itemize}

\subsection{Результаты}
Из вышеперечисленных инструментов для тестирования ПО видно, что ни один из них не удовлетворяет требованиям. Таким образом существует необходимость в создании domain specific языка для функционального тестирования, который объединит в себе принципы BDD и функционал, необходимый для симуляции работы автомобильных сетей CAN, LIN, Ethernet. Наличие такого языка значительно упростит разработку ПО и повысит качество разрабатываемого продукта.

%------------------------Уточненные требования к работе TODO
\section{Уточненные требования к работе}
%Окончательная постановка задачи с явным отсечением лишнего
%(чужого, нереализуемого и т.д.)

В результате проведенной работы должен быть разработан и реализован язык для описания тестовых сценариев для проверки качества программного обеспечения автомобильных систем.
Разрабатываемый язык описания сценариев тестирования автомобильных систем должен быть проблемно-ориентированным, предоставлять возможность пользователям самим определять набор инструкций, необходимых ля реализации тестовых сценариев.

Требования к работе:
\begin{itemize}
\itemЯзык должен позволять пользователям описывать инструкции для тестовых сценариев в свободной форме.
\itemСинтаксис языка должен позволять описывать несколько тестовых сценариев в документе.
\itemТестовые сценарии должны выполняться в той очередности, в которой описаны в документе.
\itemНеобходимо предоставить пользователю возможность работы с коммуникационными сетями автомобильных систем.
\itemРезультаты выполнения тестов должны сохраняться в файл.
\itemНеобходимо реализовать обработчик ошибок.
\end{itemize}

Качество решения, представленного в данной работе должно быть проверено следующим образом:
\begin{itemize}
\itemнеобходимо провести опрос среди потенциальных пользователей языка для выявления степени удобства \itemиспользования синтаксиса.
\itemвыполнить unit-тестирование реализации языка.
\itemвыполнить функциональное тестирование реализации языка, чтобы убедиться, что используемый язык предоставляет возможность отправлять данные на тестируемое устройство и получать данные с него.
\end{itemize}
%------------------------------------Теоретическая часть. Разработка языка
\chapter{Платформа тестирования}
\label{cDesign}
%Рекомендуемый объем главы --- 10--25 стр.
%Название главы должно отражать ее содержание, например построение вечного двигателя на основе технологий объектно-ориентированного программирования''.
%Глава должна содержать
%структурированное описание использованного метода, подхода, математического аппарата,
%разработанного алгоритма; обоснование решений, доказательство утверждений,
%аналитические оценки. Основное содержание теоретической части должны
%составлять результаты, полученные автором. При необходимости, описании
%используемых классических методов должно быть приведено в главе

%-----------------------------ТЕСТИРОВАНИЕ АВТОМОБИЛЬНЫХ СИСТЕМ



Прежде чем начать разрабатывать язык для описания сценариев тестирования автомобильных систем рассмотрим основные стандарты, используемые в транспортной промышленности.


Тестирование автомобильных систем предполагает, что поведение электрических блоков управления транспортного средства должно соответствовать стандарту UDS ISO 14229.

Принимая АС в качестве черного ящика их можно исследовать, манипулируя входными данными и обрабатывая данные, полученные на выходе. В этом случае под данными понимаются кадры автомобильной сети, передающиеся на сетевом уровне модели OSI через стандартные протоколы (CAN, FlexRay, LIN и Ethernet).

\section{Аппаратная платформа проведения исследования}
Под тестируемым оборудованием автомобильной системы подразумевается электрический блок управления (ECU), представляющий собой набор плат. Для того, чтобы управлять данным блоком, необходимо наладить канал взаимодействия с ним. Для этого, ввиду отсутствия у платы интерфейсных выходов, используется внешний интерфейсный блок. В качестве интерфейсного блока выступает аппаратное обеспечение, разработанное компанией Vector, называемое VectorBox. Данный блок представляет собой набор интерфейсов для взаимодействия по одному или нескольким протоколам. За реализацию данных протоколов отвечает встроенное программно-аппаратное обеспечение данного устройства. Схема подключения тестируемого оборудования к персональному компьютеру представлена на рис. \ref{fConnectionScheme}.


\begin{Figure}[h!]{Схема подключения тестируемого оборудования к PC}{fConnectionScheme}
{\includegraphics[width=\linewidth]{res/ConnectionScheme}}
\label{fig:image}
\end{Figure}

\section{Описание протоколов передачи данных}
Протоколы передачи данных Ethernet, LIN, CAN и FlexRay необходимы для осуществления обмена информацией между исправляющим и управляемым устройствами в автомобильной сети. Ethernet и LIN используются для малого спектра устройств. Помимо этого они используются во внутреннем обмене и для настоящий работы не представляют практического интереса. Рассмотрим подробнее протоколы CAN и FlexRay, необходимые для осуществления внешнего воздействия на тестируемое устройство.
\subsection{CAN}
Controller Area Network (сеть контроллеров) -- это стандарт промышленной сети, отличительной особенностью которого является возможность объединения различных исполнительных устройств и датчиков в единую сеть. Он обладает тремя режимами передачи данных: последовательный, широковещательный и пакетный. Данный протокол был разработан компанией Bosh в середине 1980-х и по настоящее время используется в автомобильной промышленности, промышленной автоматизации. Скорость передачи данных по CAN шине может достигать 1 Мбит/с. Отличительной особенностью этого стандарта является возможность передачи в отрыве от физического уровня модели ISO. Однако в практическом применении CAN шина основана на топологии шина с физическим уровнем в виде дифференциальной пары. Передача кадров принимается всеми узлами сети. Рассмотрим виды кадров данного протокола:
\begin{itemize}
\itemКадр данных (data frame) — передаёт данные;
\itemКадр удаленного запроса (remote frame) — служит для запроса на передачу кадра данных с тем же идентификатором;
\itemКадр перегрузки (overload frame) — обеспечивает промежуток между кадрами данных или запроса;
\itemКадр ошибки (error frame) — передаётся узлом, обнаружившим в сети ошибку.
\end{itemize}

Общий вид кадра представлен на рисунке \ref{fCAN}. В начале каждого кадра идет синхронизирующая пауза, обозначающая его начало. Следом идет 11 битный идентификатор сообщения, после которого находится поле данных изменяемой длины, но не превышающей 8 байт. Следующие 15 бит содержат контрольную сумму кадра. Далее указываются 1 битные поля: разграничитель контрольной суммы, который должен быть притянутым к нулю, промежуток подтверждения(при отправке выставляется в 0, при приеме в 1) и разграничитель подтверждения (должен быть равным нулю). Завершающим полем является конец кадра, длина которого 7 бит.

\begin{Figure}[h!]{Кадр протокола CAN}{fCAN}
{\includegraphics[width=\linewidth]{res/CAN}}
\label{fig:image}
\end{Figure}

\subsection{FlexRay}
В 2004 году компания NXP совместно с BMW, Diamler, Bosh, GM и Volkswagen представила новый сетевой протокол для автомобилей. Этот высокоскоростной сетевой протокол обладает пропускной способностью до 10 Мбит/с. Данная шина работает в цикле из двух сегментов: статического и динамического. Статический сегмент разделен на участки для отдельных типов обменов, предоставляя гарантии реального времени. Динамический сегмент в свою очередь работает по принципу, схожему с шиной CAN, где в данном случае контроль над шиной может быть получен участниками топологии в любой момент времени. Данный протокол используют вместо CAN, когда важна высокая скорость передачи данных.

Кадр данного протокола, представленный на рисунке \ref{fFlexRay}, разделен на три сегмента. Заголовочный сегмент состоит из полей постоянной длины. Первые пять бит отводятся под управляющие сигналы, к которым относятся: специально зарезервированный бит, бит указателя преамбулы, индикатор нулевого кадра, бит синхронизации, бит начала кадра. Следующие 11 бит представляют собой поле, хранящее идентификационный номер кадра. Длина полезной информации, которую несет в себе кадр, содержится в следующих 7 битах. На основе этих двух полей производится вычисление контрольной суммы заголовочного сегмента, которая хранится в следующих 7 битах.  Последние 6 бит заголовочного сегмента являются счетчиком. Таким образом длина заголовочного сегмента равна 5 байтам.

\begin{Figure}[h!]{Кадр протокола FlexRay}{fFlexRay}
{\includegraphics[width=\linewidth]{res/FlexRay}}
\label{fig:image}
\end{Figure}

Следом за заголовком идет сегмент полезных данных, который состоит из $n$ полей. Длина каждого из полей равняется 1 байту. Количество полей регулируется в заголовке. Замыкающим сегментом является трехбайтная контрольная сумма, которая высчитывается на основе всего кадра.


\section {Сценарии тестирования}
Для функционального тестирования автомобильных систем требуются специальные навыки в области автомобильной промышленности. Однако существуют общие способы проверки качества разрабатываемого программного обеспечения, которые, в том числе можно применить и к валидации ПО транспортных средств.
Поведенческое тестирование автомобильных систем может быть выполнено следующими способами:
\begin{itemize}
\itemРазделение на классы эквивалентности

Часто легко заметить, что входные данные имеют схожие характеристики. В этом случае их можно сгруппировать и подавать на вход только одну единицу данных из каждой группы.  Идея заключается в разделении входных данных на классы эквивалентности таким образом, что каждый член класса обладает схожими характеристиками.

Данный способ включается в себя два шага: определение класса эквивалентности и генерацию тестовых сценариев. Под определением класса эквивалентности подразумевается разделение входных данных на два класса: корректные и некорректные данные. Например, если действительный диапазон данных от 0 до 100, то в качестве корректных данных может быть выбрано значение 49, а в качестве некорректного 106.

\itemАнализ граничных значений

Тестирование граничные значения данных позволяют достаточно хорошо проверить качество программного обеспечения. Следовательно, если тестовые сценарии разработаны для граничных значений входной области, то эффективность тестирования повышается. Например, если действительный диапазон данных от 0 до 100, то в качестве корректных данных выбираются граничные значения 0 и 100 для корректных данных, а в качестве некорректных -1 и 101.

\itemТестирование, основанное на требованиях

Данный способ тестирования подразумевает валидацию требований, предоставленных аналитиками и инженерами, которые составляют требования. Например, если в требовании описано, что сеть должна переходить в активный режим при получении любого кадра, то в качестве входных данных формируется любой корректный в данной сети кадр.
\end{itemize}

Основываясь на общепринятых способах проверки качества программного обеспечения, а так же специфики области автомобильной промышленности алгоритм тестирования можно описать следующим образом:
\begin{enumerate}
\itemиз тестовой инструкции извлекаются данные, необходимые для отправки на ECU;
\itemданные преобразуются в кадры управления VectorBox'ом;
\itemинтерфейсный блок управления (VectorBox) генерирует управляющие сигналы и отправляет их на ECU;
\itemпосле выполнения полученной инструкции ECU генерирует ответ, который отправляется на VectorBox;
\itemпосле получения ответа от ECU VectorBox генерирует кадр и передает через интерфейс пользовательскому компьютеру (PC);
\itemполученный кадр ответа транслирующая система сравнивает с ожидаемым значением, описанным в тестовой спецификации;
\end{enumerate}

Из вышесказанного можно сделать вывод, что разрабатываемый язык для описания сценариев тестирования автомобильных систем должен предоставлять пользователям возможность передачи данных на сетевом уровне модели ISO по протоколам CAN, FlexRay и сравнения получаемых данных с ожидаемыми.

%-------------------------------СИНТАКСИС ЯЗЫКА
\chapter{Методы описания и реализации проблемно-ориентированных языков}
\section{Описание синтаксиса языка }
Существуют три основных метода описания синтаксиса языков программирования: формальные грамматики, формы Бэкуса-Наура и диаграммы Вирта.

Формальной грамматикой называется четверка вида: G = (VT, VN, P, S),

где где VN - конечное множество нетерминальных символов грамматики,
VT - множество терминальных символов грамматики
Р – множество правил вывода грамматики,
S – начальный символ грамматики.

Для записи правил вывода с одинаковыми левыми частями вида a-> b1, a->b2, ..., a->bn  используется сокращенная форма записи a-> b1|b2|...|bn.

%БНФ

Во второй половине 20-го века Джон Брэкус и Ноам Хомски независимо друг от друга создали форму записи, которая в последствии стала методом формального описания синтаксиса языков \cite{conceptPL}.
Форма Бэкуса-Наура (БНФ) – формальная система описания синтаксиса, используемая для описания контекстно-свободных грамматик, в которой одни синтаксические абстракции последовательно определяются через другие абстракции. Для описания синтаксических структур форма БНФ использует абстракции.

Форма БНФ является порождающим устройством для определения языков. С помощью последовательности правил создаются предложения языка. Создание предложений называется выводом.
Вывод должен начинаться с начального символа (start symbol). Сентенциальная форма грамматики — это строка, которая может быть выведена из стартового символа. Предложение (сентенция) грамматики — это сентенциальная форма, состоящая только из терминальных символов. Язык L(G) грамматики — это множество всех ее предложений.

Метаязык, предложенный Бэкусом и Науром, использует следующие обозначения:
\begin{itemize}
\itemсимвол «::=» отделяет левую часть правила от правой (читается: «определяется как»);
\itemнетерминалы обозначаются произвольной символьной строкой, заключенной в угловые скобки «<» и «>»;
\itemтерминалы - это символы, используемые в описываемом языке;
\itemправило может определять порождение нескольких альтернативных цепочек, отделяемых друг от друга символом вертикальной черты «|» (читается: «или»).
\end{itemize}


%РБНФ
Из-за некоторых незначительных неудобств в БНФ Никлаус Вирт предложил свой вариант расширенной формы Бэкуса-Наура (РБНФ, расширенная Бэкус — Наурова форма). Эти расширения не увеличивают описательную силу БНФ, а упрощают чтение и использование такой формы.

Для повышения удобства и компактности описаний, в РБНФ вводятся следующие дополнительные конструкции (мета символы):
\begin{itemize}
\itemквадратные скобки «[» и «]» означают, что заключенная в них синтаксическая конструкция может отсутствовать;
\itemфигурные скобки «\{» и «\}» означают повторение заключенной в них синтаксической конструкции ноль или более раз;
\itemсочетание фигурных скобок и косой черты «\{/» и «/\}» используется для обозначения повторения один и более раз;
\itemкруглые скобки «(» и «)» используются для ограничения альтернативных конструкций.
\end{itemize}

%Диаграммы Вирта

Синтаксическими графами называются ориентированные графы, на которых представляется информация о правилах форм БНФ и РБНФ. Так же их называют синтаксическими диаграммами или синтаксическими схемами.
При построении диаграмм учитывают следующие правила:
\begin{itemize}
\itemкаждый графический элемент, соответствующий терминалу или нетерминалу, имеет по одному входу и выходу, которые обычно изображаются на противоположных сторонах;
\itemкаждому правилу соответствует своя графическая диаграмма, на которой терминалы и нетерминалы соединяются посредством дуг;
\itemальтернативы в правилах задаются ветвлением дуг, а итерации — их слиянием;
\itemдолжна быть одна входная дуга (располагается обычно слева или сверху), задающая начало правила и помеченная именем определяемого нетерминала, и одна выходная, задающая его конец (обычно располагается справа и снизу);
\itemстрелки на дугах диаграмм обычно не ставятся, а направления связей отслеживаются движением от начальной дуги в соответствии с плавными изгибами промежуточных дуг и ветвлений.
\end{itemize}

%Компилируемый или интерпретируемый?
\section{Разработка языка}
Существует два главных вида языков программирования: компилируемый и интерпретируемый.
Компилятор выясняет все, что должна выполнить программа, превращает инструкции в машинный код и сохраняет его, чтобы выполнить позже.
Интерпретатор проходит всю программу строчку за строчкой и тут же выполняет.

Технически любой язык может быть, как компилируемым так и интерпретируемым. Обычно компилируемый язык выбирают, если в программе важна скорость работы. Интерпретируемый же язык более гибкий.

В случае разработки интерпретатора стадии разработки можно разбить на следующие этапы:

\begin{itemize}
\itemЛексический анализ – разбор исходного кода на токены. Этот этап выполняется лексером;
\itemСинтаксический анализ – сбор токенов в абстрактное синтаксическое дерево (AST). Данный этап выполняется синтаксическим анализатором (парсером);
\itemСемантический анализ;
\itemИсполенение AST.
\end{itemize}



Естественные языки и искусственные, вне зависимости от их происхождения, представляют собой совокупность строк, состоящих из символа некоторого алфавита. Предложения или утверждения – это строки, состоящие из символов языка. Какие именно утверждения существуют в языке определяют синтаксические правила.

%---------------------------------------ЛЕКСИЧЕСКИЙ АНАЛИЗ
\subsection {Лексичекий анализ}
Первым шагом в разработке языков зачастую является лексический анализ – процесс аналитического разбора входной последовательности символов на лексемы, с целью получения на выходе идентифицированных последовательностей, называемых токенами. Токен – это малая единица языка. Токен может быть именем переменной или функции, оператором или числом.

Предполагается, что лексер берет входную строку, содержащую файлы с исходным кодом на разрабатываемом языке и разделяет его на список токенов. Лексер может выполнять такие задачи, как удаление комментариев, определение чисел и т.д.

ЛА необязательный этап, но желательный так как:

1) замена идентификаторов, констант, ограничителей и служебных слов лексемами делает программу более удобной для дальнейшей обработки.

2) Лексический анализатор уменьшает длину программы, устраняя из ее исходного представления комментарии и несущественные пробелы.

3) если будет изменена кодировка в исходном представлении программы, то это отразится только на лексическом анализаторе.

В процедурных языках лексемы обычно делятся на классы: служебные слова и ограничители.


Входные данные ЛА — текст транслируемой программы на входном языке.

Выходные данные ЛА — файл лексем в числовом представлении. %TODO добавить листинг BddLexer.tokens


\subsection {Синтаксический анализ}
%синтаксический анализ
Синтаксический анализ – это процесс сопоставления линейной последовательности лексем (слов, фраз) языка с его формальной грамматикой. Результатом обычно является синтаксическое дерево. Обычно применяется совместно с лексическим анализом. Синтаксический анализатор— это программа или часть программы, выполняющая синтаксический анализ, то есть распознавание входной информации. При этом входные данные преобразуются к виду, пригодному для дальнейшей обработки. Этот вид обычно представляет собой формальную модель входной информации на языке последующего процесса обработки информации.

Во время парсинга входной текст преобразуется в структуру данных, которая отражает синтаксическую структуру входной последовательности и подходит для последующей обработки. Как правило, синтаксическая структура представляется в виде дерева зависимостей.

Существуют следующие алгоритмы синтаксического анализа:
\begin{itemize}
\itemНисходящий (англ. top-down) – это такой анализ, в котором продукции грамматики раскрываются, начиная со стартового символа, до получения требуемой последовательности лексем.
\itemВосходящий (англ. bottom-up) – это такой анализ, в котором продукции восстанавливаются из правых частей, начиная с токенов-лексем и кончая стартовым символом.
\end{itemize}

Нисходящий анализ (метод рекурсивного спуска) является наиболее эффективным методом синтаксического анализа. В его основе лежит левосторонний разбор строки языка. Исходной сентенциальной формой является начальный символ грамматики, а целевой – заданная строка языка. На каждом шаге разбора правило грамматики применяется к самому левому нетерминалу сентенции. Данный процесс соответствует построению дерева разбора цепочки сверху вниз (от корня к листьям).

%ДЕРЕВЬЯ СИНТАКСИЧЕСКОГО АНАЛИЗА


\subsection {Семантический анализ}
\label{sSemanthAnalysis}
В ходе семантического анализа проверяются отдельные правила записи исходных программ, которые не описываются контекстно-свободной грамматикой. Эти правила носят контекстно-зависимый характер, их называют семантическими соглашениями или контекстными условиями.

Пользовательские инструкции, используемые в тестовых сценариях должны быть заранее объявлены пользователями в специальной библиотеке. Так как инструкции должны быть сформулированы в произвольной форме, обговоренной внутри команды, состоящей из аналитиков и тестировщиков, то в качестве библиотеки может использоваться java класс, в котором для каждой инструкции тестироващики должны для реализовать отдельный метод. Чтобы разделить входные инструкции по смысловой нагрузке на входные и выходные данные и прикрепить к каждой инструкции метод, необходимый для ее выполнения разумно создать java-аннотации, название которых будет соответствовать ключевым словам языка: Send-- для отправки данных, Recieve -- для получения данных и т.д.
В теле метода  соответствующей инструкции должны быть реализованы шаги отправки, получения данных и т.д., в зависимости от аннотации.

Для того, чтобы определить метод, который должен быть выполнен при вызове заданной текстовой инструкции, а так же приведения типов пользовательских параметров, можно использовать рефлексию.

Рефлексия (от лат. reflexio — обращение назад) — это механизм исследования данных о программе во время её выполнения. Рефлексия позволяет исследовать информацию о полях, методах и конструкторах классов.

Механизм рефлексии позволяет обрабатывать типы, отсутствующие при компиляции, но появившиеся во время выполнения программы. Возможность использования рефлексии реализована в Java с помощью Reflection API.  Библиотека java.lang.reflect предоставляет возможность манипулировать кодом Java в динамическом режиме.

% ------------------------------------------------ГЛАВА Реализационная часть
\chapter{Описание разрабатываемого языка}
\label{cImplementation}
%Рекомендуемый объем главы --- 10-30 стр.
%Название главы должно отражать ее содержание, например  "Архитектура вечного двигателя''.
%В главе должно быть описание этапов разработки технического решения задачи. Следующий пример
%приведен для работ, связанных с проектированием и реализацией
%программного продукта.


Задача построения языка довольна трудозатратна. Однако существуют программные инструменты, помогающие сделать его меньше и проще. Для этого был разработан следующий инструментарий для создания компиляторов: генераторы лексических анализаторов (сканеров), генераторы синтаксических анализаторов (парсеров), автоматические генераторы кода.

Для реализации языка было выбрано «еще одно средство распознавания языков» ANTLR4 (ANother Tool for Language Recognition). Это генератор нисходящих анализаторов для формальных языков. Он преобразует контекстно-свободную грамматику в форме РБНФ в программу на Java, C++, JavaSript, Go. Python и Go.

ANTLR4 удобен для работы с AST, является свободным программным обеспечением, предоставляет сообщение об ошибках и восстановление после них, а так же предоставляет плагины для Eclipse и IntelliJ IDEA, что позволяет удобно создавать и отлаживать грамматики. Интерпретатор реализован на языке java.

Описание грамматики в ANTLR4 состоит из правил, описываемых в файлах с расширением \textbf{.g4}.  ANTLR4 позволяет описывать лексемы и синтаксические правила в одном файле грамматики. В этом случае в заголовке файла указывается ключевое слово grammar'' и название грамматики, которое должно совпадать с названием файла, в котором она описывается. Так же генератор позволяет разделять их на файлы, в котором описываются лексемы (заголовок lexer grammar) и синтаксические правила (parser grammar). Второй способ удобнее с точки зрения логического разделения описания лексем и правил. Далее файл, в котором описываются лексемы будем называть лексером, а файл, в котором описываются синтаксические правила лексером.

%-------------------------------------ЛЕКСЕР
\section{Лексический анализатор}
Предметно-ориентированный язык для описания тестовых сценариев автомобильных систем должен позволять описывать следующие виды инструкций, необходимых для описания входных и выходных данных:
\begin{itemize}
\itemОтправить кадр, сигнал или набор данных по UDS протоколу на тестируемое ПО;
\itemПолучить кадр, сигнал или набор данных по UDS протоколу от тестируемого ПО;
\itemВыполнить паузу между инструкциями, чтобы тестируемое ПО успело сформировать и отправить необходимые данные;
\itemВыполнять шаги определенное количество раз, т.к. многие системы имеют алгоритмы со счетчиками, которые можно выполнить определенное количество раз. Зачастую значения таких счетчиков измеряются сотнями и даже тысячами шагов. При удачной группировке этих шагов количество строк тестового сценария можно сократить в десятки раз, поместив из в цикл;
\itemВыполнять определенные действия по событию (триггер);
\itemУстановить значение отправляемого сигнала;
\itemПроверить полученное значение сигнала;
\end{itemize}

При этом команды, состоящие из аналитиков, тестировщиков и разработчиков должны сами определять набор инструкций, так как в процессе разработки автомобильного ПО могут выявляться свойства, специфичные для того или иного программного продукта. У пользователей должна быть возможность описать сценарии в свободной форме с иcпользованием проектно-специфичных терминов (например рычаги для тестирования ECU рулевой колонки, расстояние, видимость и уровень загрязнения сенсора для тестирования ECU лидара и т.д).
Предполагается, что пользователи (заказчики, аналитики, менеджеры, разработчики и тестировщики) сами определяют ограниченный набор шагов, необходимых для описания тестовых сценариев в целом. Из пула обговоренных инструкций тестировщики составляют набор шагов для каждого тестового сценария, основываясь на предоставленных требованиях.


Предположим, что синтаксис разрабатываемого языка будет иметь ключевые слова, по которым можно определить входные и выходные данные, возможность описывать сценарии на языке, привычном пользователю, будь то русский или английский.

В качестве входов системы рассмотрим пакеты данных, отправляемые тестируемому оборудованию, а так же установку значений параметров (частота передачи данных, значения отправляемых сигналов и д.р.). В этом случае входы системы можно разделить на два класса: отправка данных и настройка данных. В таком случае выходами системы будут получаемые с тестируемого оборудования пакеты данных. Данные могут приниматься единожды (UDS пакеты), или же периодически (синхросигналы). Соответственно, представляется логичным разделить их на две большие группы: получение пакетов и данные, которые необходимо проверить в определенный момент времени. В этом случае система управления имеет входы $X(Send_{data}, Set_{data})$ и выходы $Y(Recieve_{data}, Check_{data})$. На рис. \ref{blackBoxKeyWords} в качестве входных и выходных данных черного ящика'' представлены ключевые слова, которыми назовем четыре группы вышеописанных данных.

\begin{Figure}{Тестирование автомобильной системы в качестве черного ящика''}{blackBoxKeyWords}
{\includegraphics[width=\linewidth]{res/blackBoxKeyWords}}
\label{fig:image}
\end{Figure}



Из вышеуказанного можно определить следующий набор ключевых слов с которых должен начинаться любой шаг сценария:  \textbf{Send}, \textbf{Set}, \textbf{Check}, \textbf{Receive}, \textbf{Pause}. При этом ключевые слова должны начинаться с определенного начального символа, обозначающее начало служебного слова. При тестировании программного обеспечения ECU для автомобильных систем наименее вероятно использование символа коммерческое at(  @''), поэтому этот символ будет обозначать ключевые слова.

%%%%%%%%%%%%%%%%%


Данные лексемы реализованы в лексере BddLexer.g4 и представлены в листинге \ref{lst:listKeyWords}.
При этом для удобства пользователя первая буква ключевые слова языка должны быть регистронезависимы.
К сожалению, в ANTLR нет поддержки регистронезависимых токенов, и для токенов приходится использовать следующую запись с использованием фрагментных токенов, которые используются для построения реальных токенов:

fragment S: [sS];

\lstinputlisting[caption=Ключевые слова, language=java,  firstline=26,  lastline=39 , label = {lst:listKeyWords}]{res/BddLexer.g4}

Так как автомобильные системы тестируются в режиме реального времени, в тестовых сценариях необходимо явно оперировать временем. Ответ на запрос приходит не моментально, так же как и не моментально изменяются значения сигналов. Зачастую возникает необходимость проверить значение полученного сигнала несколько раз в определенные промежутки времени. В этом случае между отправкой запроса и получением ответа необходимо установить паузу, в течение которой тестовое оборудование не будет выполнять проверку полученных данных на соответствие ожидаемым данным, описанные в тестовом сценарии. Для реализации этой возможности введем ключевое слово Pause. После данного ключевого слова должно указываться значение $p_n$ такое, что $t_{n+1}=t_n+p_n$. лексемы, необходимые для паузы представлены на листинге \ref{lst:lPause}

\lstinputlisting[caption=Лексемы паузы, language=java,  firstline=8,  lastline=14 , label = {lst:lPause}]{res/BddLexer.g4}


После шага должна идти инструкция, определяемая пользователем языка. Например, если необходимо проверить функцию записи определенных данных в энергонезависимой памяти, нужно реализовать следующий набор шагов тестового сценария:

\begin{itemize}
\itemВключить тестовое оборудование
\itemС помощью сервиса UDS протокола WriteDataByIdentifier (0x2E) записать корректные данные
\itemС помощью сервиса UDS протокола ReadDataByIdentifier (0x22) проверить, что данные успешно записаны
\itemВыключить тестируемое оборудование
\itemВключить тестируемое оборудование
\itemС помощью сервиса UDS протокола ReadDataByIdentifier (0x22) прочитать записанные данные
\itemВыключить тестируемое оборудование
\end{itemize}

Предположим, что для области памяти с адресом 0xF101 корректными данными являются три байта 0x0001A5.
В этом случае, в соответствии с принципами BDD набор тестовых инструкций, определяемых пользователем могут выглядеть следующим образом:

\textbf{@Set} ignition on,
\textbf{@Send} request 22 F1 01 00 01 A5,
\textbf{@Recieve} response 62 F1 01,
\textbf{@Set} ignition off,
\textbf{@Set} ignition on,
\textbf{@Send} request 2E F1 01,
\textbf{@Pause} 100 ms,
\textbf{@Recieve} response 6E F1 01 00 01 A5,
\textbf{@Set} ignition off.

Такая запись не очень удобна с точки зрения восприимчивости теста. Поэтому разумно ввести правило, что каждое правило должно начинаться с новой строки. При этом, чтобы улучшить читабельность тестового сценария должна быть возможность отделять некоторые шаги в логические блоки (например разделить шаги на блоки до выключения'' и после включения'' тестируемого оборудования''). Сделать это можно добавив еще несколько пробелов. Для обозначения новой строки введем лексему \textbf{NewLine} (листинг \ref{lst:lnewLine}). Подробнее правила синтаксического анализа будут рассмотрены в разделе \ref{lParser}.

\lstinputlisting[caption=Лексема новой строки, language=java,  firstline=5,  lastline=6 , label = {lst:lnewLine}]{res/BddLexer.g4}



Так же в приведенном примере легко заметить, что существуют похожие инструкции:
\\\textbf{Send} request 22 F1 01 00 01 A5
\\\textbf{Send} request 2E F1 01.

Приведенный в качестве примера тестовый сценарий достаточно короткий, на практике же количество различных отправляемых и получаемых данных у одной и той же инструкции в рамках одного лишь сценария может достигать десяти и даже сотни.
Если ввести возможность описывать инструкции с использованием параметров, можно достичь значительной оптимизации процесса тестирования, так как тестироващикам будет необходимо реализовать для однотипных инструкций только один метод, оперирующий данными, указанными в качестве параметров.



Из примера кажется очевидным ввести лексему параметра в виде шестнадцатеричного кода. Однако на практике в качестве параметров имеет смысл использовать так же и целочисленные значения и значения с плавающей точкой (например, проверка и установка значений сигнала), а так же связный текст (например описание названия сигнала, способа адресации и т.д.).
Допустим, пользователи определили следующий ограниченный набор команд: «Отправить запрос ‘запрос’», «Получить ответ ‘ответ’». Очевидно, что инструкция, состоящая из одного лишь параметра не имеет смысла. Так как текст инструкции и параметры формулируются в произвольной форме, то необходимо выделить отдельные лексемы, обозначающие начало и конец параметра. Реализация данных лексем представлена на листинге \ref{lst:lparam}.


\lstinputlisting[caption=Лексемы начала и конца параметра, language=java,  firstline=43,  lastline=46 , label={lst:lparam}]{res/BddLexer.g4}

Более того, нет обозначения начала тестового сценария. Так же в тестовой спецификации должна быть краткая информация для каждого сценария, чтобы можно было быстро понять зачем нужно данное испытание.  Для этого введем ключевое слово \textbf{TestCase}, обозначающее начало сценария, после которого должна идти краткая информация.
Шаги группируются в тестовые сценарии, которых в тестовой спецификации может быть несколько.

После введения выше описанных лексем вид предполагается, что тестовый сценарий будет иметь следующий вид:
\\\textbf{@TestCase} testing NVRAM functionallity of did 0xF101
\\\textbf{@Set} ignition on,
\\\textbf{@Send} request [22 F1 01 00 01 A5],
\\\textbf{@Recieve} response [62 F1 01],
\\\textbf{@Set} ignition off,
\\\textbf{@Set} ignition on,
\\\textbf{@Send} request [2E F1 01],
\\\textbf{@Pause} 100 ms,
\\\textbf{@Recieve} response [6E F1 01 00 01 A5],
\\\textbf{@Set} ignition off.

%---------------------------------ПАРСЕР
\section{Синтаксический анализатор}\label{lParser}
За реализацию РБНФ правил в ANTLR4 грамматике отвечает парсер BddParser.g4. Чтобы использовать лексемы, описанные в  лексере BddLexer.g4 необходимо указать файл, в котором они описаны. В ANTLR4 для этого используется ключевое слово options, после которого в фигурных скобках указывается словарь:
\\options \{ tokenVocab=BddLexer; \}


Для описания синтаксической структуры языка нужно определить порядок записи:
\begin{itemize}
\itemПредложений в тексте;
\itemФраз в предложении;
\itemЛексем и фраз в более общих фразах.
\end{itemize}

Для разрабатываемого языка необходимы такие синтаксические правила как текст инструкции и кастомизированный параметр. При этом текст может содержать пробелы, любые символы английского и русского языков, а так же любые другие символы, кроме символов, обозначающих начало и конец кастомизированного параметра, а так же служебный символ «@», обозначающий начало ключевого слова.

Синтаксические правила одного шага можно описать следующим образом:

\begin{itemize}
\itemШаг должен начинаться с ключевого символа, определяемого служебным символом “@”;
\itemЕсли шаг начинается с ключевого слова \textbf{@Send}, \textbf{@Receive}, \textbf{@Set} или \textbf{@Check}, то далее должен идти текст инструкции.
\itemЕсли шаг начинается с ключевого слова \textbf{@Pause}, то далее должно быть число и, по желанию, текст для описания шага.
\end{itemize}


При анализе узлов дерева разбора нужно обращаться к дочерним узлам, соответствующим фрагментам исходного правила. Причем обращаться можно как к отдельным узлам, так и к группам узлов. Следовательно, важным условием создания хорошей грамматики является возможность интуитивно простой доступ к любой части правила. ANTLR4 предоставляет такие сущности как альтернативные и элементарные метки. Альтернативные метки позволяют разбить сложное правило на альтернативные фразы и обрабатывать каждую фразу отдельно.
Элементными метками помечаются отдельные нетерминалы или последовательности терминалов. Они предоставляют доступ к содержимому контекста правила в виде поля с заданным именем. Таким образом, вместо вычисления (извлечения) отдельного элемента содержимого некоторого контекста достаточно просто обратиться к такой элементной метке.
Правило шага можно разбить на альтернативные метки \textbf{send}, \textbf{receive}, \textbf{set} \textbf{check}, \textbf{pause}, представленные на листинге \ref{lst:BddParser}
\lstinputlisting[caption= альтернативные метки синтаксического правила instruction,language=java,  firstline=15,      lastline=21 , label={lst:BddParser}]{res/BddParser.g4}



Текст инструкции \textbf{annotationText} (листинг \ref{lst:lAnnotationText}).
\begin{itemize}
\itemне может начинаться с пользовательского параметра;
\itemможет не иметь параметров;
\itemможет иметь сколь угодно много параметров, чередующихся с текстом.
\end{itemize}
\lstinputlisting[caption= синтаксическое правило текста инструкции, language=java,  firstline=32,      lastline=39 , label={lst:lAnnotationText}]{res/BddParser.g4}


Правило для параметра можно описать следующим образом: пользователь должен указать символы, обозначающие начало и конец параметра (в лексере они указаны как квадратные скобки  ['' и  ]''). Внутри скобок находится значение параметра, которое может быть как текстом, так и числом. При этом значение параметра может отсутствовать (листинг \ref{lst:lcustomParameter}).
\lstinputlisting[caption= синтаксическое правило для параметра, language=java,  firstline=27,      lastline=29 , label={lst:lcustomParameter}]
{res/BddParser.g4}


Так как тестовых сценариев в одном документе может быть несколько, то введем правило для описания тестовой спецификации  (листинг \ref{lst:specification}): тестовые сценарии объединяются в элементарную метку \textbf{testcases}. При этом в синтаксическом правиле тестового сценария \textbf{testcase} укажем, что он должен начинаться с лексемы \textbf{TestCase}, после которой следует его описание. С новой строки \textbf{eoi} следует правило \textbf{scenario}, в котором объединяются шаги одного тестового сценария.


\lstinputlisting[caption= синтаксическое правило для параметра, language=java,  firstline=5,      lastline=13 , label={lst:specification}]
{res/BddParser.g4}

Абстрактное синтаксическое дерево построенное для примера тестовой  вышеописанным правилам синтаксического анализа тестовый сценарий

Из вышеописанных синтаксических правил пример тестовой спецификации для тестирования функции записи данных в энергонезависимую память будет выглядеть следующим образом:
\\\textbf{@TestCase} testing NVRAM functionallity of did 0xF101
\\\textbf{@Set} ignition on,
\\\textbf{@Send} request [22 F1 01 00 01 A5],
\\\textbf{@Recieve} response [62 F1 01],
\\\textbf{@Set} ignition off,
\\\textbf{@Set} ignition on,
\\\textbf{@Send} request [2E F1 01],
\\\textbf{@Pause} 100 ms,
\\\textbf{@Recieve} response [6E F1 01 00 01 A5],
\\\textbf{@Set} ignition off.

На рисунке \ref{fAST} проиллюстрировано абстрактное синтаксическое дерево для правила \textbf{specification}.
\begin{Figure}[h!]{Пример AST тестовой спецификации}{fAST}
{\includegraphics[width=\linewidth]{res/parseTree}}
\label{fig:image}
\end{Figure}





%-------------------------------Реализация языка
\chapter{Реализация языка}
\label{cImplementation2}
\section{Компилятор}



По описанным в главе \ref{cImplementation} грамматическим правилам ANTLR4 генерирует файлы для распознания.
BddLexer.java-- это описание класса лексера, или лексического анализатора, отвечающего грамматике BddLexer. BddParser.java-- это описание класса парсера, то есть синтаксического анализатора, отвечающего грамматике BddParser.
BddParser.tokens, BddLexer.tokens — это вспомогательные классы, которые содержат информацию о токенах.


Для использования разработанного парсера ANTLR4 представляет возможность сгенерировать два паттерна проектирования: Visitor (посетитель) и Listener (слушатель). Каждый из них предполагает анализ определенного подмножества узлов дерева разбора. Узлы дерева разбора, не являющиеся листьями, соответствуют каким-либо синтаксическим правилам грамматики.

В реализации языка используется паттерн Listener. BddParserListener.java, BddParserBaseListener.java— это интерфейс и класс, содержащие описания методов, которые позволяют выполнять действия, необходимые при обходе синтаксического дерева.


Прежде чем описывать тестовые сценарии на разрабатываемом языке, необходимо определить конечный набор текстовых инструкций. При этом для каждой инструкции нужно указать набор шагов, необходимых для выполнения при обнаружении данной инструкции в тестовом сценарии. Так как разрабатываемый язык реализуется на языке java, то и текстовые инструкции разумно описывать на java.


Для описания пользовательских текстовых инструкций можно ввести специальные Java-аннотации. Аннотации в java-- это механизм для добавления информации о метаданных к исходному коду. Это мощнейшая часть java, которая была добавлена в JDK5. Аннотации предлагают альтернативу использованию XML описания и маркерных интерфейсов. Аннотации могут быть прикреплены к пакетам, классам, методам и полям, однако сами по себе java-аннотации не имеют никакого эффекта на осуществление программы.

Введем новые аннотации, названия которых будут совпадать с ключевыми словами: Send, Set, Check и Recieve. С помощью мета-аннотаций @Retention и @Target определим область видимости и цель назначения для новых аннотаций. В листинге \ref{lst:checkAnnotatoin} представлена реализация аннотации для ключевого слова Check: она имеет видимость  во время выполнения и может быть применена к методам. Так же аннотация имеет метод text(), отвечающий за хранение текстовой инструкции. Аннотации Send, Recieve и Set имеют аналогичную реализацию.
\lstinputlisting[caption=реализация аннотации Check,language=java,  firstline=1,  lastline=6, label={lst:checkAnnotatoin}]{res/CheckAnnotation.txt}

Для описания конечного набора инструкций, необходимых для описания тестовых сценариев введем класс CommandLib.java. Это библиотека пользовательских инструкций, в которой тестировщики должны описать методы, которые позволяют выполнять действия, необходимые для этих инструкций. Предположим, что для тестирования программного обеспечения для автомобильных систем одной из набора заранее обговоренных в команде фраз является фраза Send request [req]''. В этом случае необходимо реализовать метод с аннотацией Send, у которой метод text() возвращает текстовую инструкцию. При этом текстовая инструкция содержит параметр req, который так же необходимо указать в качестве параметра метода. В листинге \ref{lst:SendMethod} представлена реализация данной инструкции.

\lstinputlisting[caption=метод с аннотацией Send,language=java,  firstline=8,  lastline=12, label={lst:SendMethod}]{res/CheckAnnotation.txt}

Во время обхода абстрактного синтаксического дерева необходимо по тексту инструкции, следующим после ключевого слова, находить и выполнять метод, определенный в пользовательской библиотеке CommandLib. Как обсуждалось в разделе \label{sSemanthAnalysis}, в java такая возможность может быть достигнута благодаря Reflection API. Рефлексия позволяет производить анализ функциональных возможностей классов. Пакет java.lang.reflection содержит классы Field, Method и Constructor, соответственно описывающие поля, методы и конструкторы класса. Метод getMethods() возвращает массив открытых методов, принадлежащих анализируемому классу\cite{JavaTom1}. В данном случае анализироваться должен класс пользовательской библиотеки CommandLib.java.

При обходе абстрактного синтаксического дерева компилятор находит очередную нотированную инструкцию, с помощью рефлексии находит метод, аннотированный соответствующим ключевым словом и добавляет ее в список необходимых для выполнения. При этом инструкция должна быть заранее определена пользователем в библиотеке инструкций. Во время семантического анализа все параметры пользовательских параметров приводятся к типам, объявленным в параметрах метода. Методы инcтрукций могут принимать параметры следующих типов: boolean, byte, short, integer, long, float, double, String, Enum.

При завершении обхода AST инструкции поочередно выполняются в том порядке, в котором были заданы в тестовой спецификации.

\lstinputlisting[caption=Пример реализации пользовательской инструкции с аннотацией Send,language=java, label={lst:annotatoinExample1}]{res/annotatoinExample.txt}

Для реализации функционала симуляции автомобильных сетей используется XL-Driver-Library. XL-Driver-Library -- это универсальный программный интерфейс, позволяющий получить доступ к интерфейсам аппаратных средств Vector. Он поддерживает следующие шины:
\begin{itemize}
\item CAN / CAN FD
\item LIN
\item FlexRay
\item Automotive Ethernet
\item MOST
\item ARINC
\end{itemize}

XL-Driver-Library предоставляет общие и шинно-специфичные методы, которые облегчают управлять интерфейсами шины от Vector. Каналы и порты управляются общими методами. Шинно-специфичные методы используются, чтобы настроить сетевые узлы и послать или получить сообщения.  XL-Driver-Library позволяет эффективно использовать интерфейсы шины в пользовательских приложениях. Особенно полезно это при реализации специализированных инструментов, которые адаптированы к автоматизированному рабочему месту и его окружению, с целью увеличения производительности.
По словам производителей данная библиотека может быть использована при создании инструментов тестирования для тестового оборудования автомобильных систем.

Для разработки XL Driver Library приложений требуется подключить динамические библиотеки, которые находятся в открытом доступе на сайте компании Vector. Необходимые методы реализованы на языке С, поэтому для доступа к методам через java был реализован класс JNIVxlApi.java c использованием механизма JNI.

Java Native Interface (JNI) — стандартный механизм для запуска кода, под управлением виртуальной машины Java (JVM), который написан на языках С/С++ или Ассемблера, и скомпонован в виде динамических библиотек, позволяет не использовать статическое связывание. Это даёт возможность вызова функции С/С++ из программы на Java, и наоборот.

%----------------------Архитектура системы
%\section{Архитектура системы}
%Псевдокоды или блок-схемы основных алгоритмов, основные структуры данных и др.

Ниже представлена диаграмма классов интерпретатора.

\begin{figure}[h]
\center{\includegraphics[width=\linewidth]{res/ClassDiagram}}
\caption{Диаграмма классов}
\label{fig:image}
\end{figure}


%------------------------Интерфейс системы
%\section{Интерфейс системы}
%\label{sSpec}
%Интерфейс пользователя, модульная структура, API
%\section{Особенности реализации}
%Использованные инструментальные средства, приемы программирования,
%технические решения, связанные с ограничениями аппаратных или программных
%средств.


%--------------------------------------Обработчик ошибок
\section{Обработчик ошибок}
Важной способностью каждого парсера является обработка ошибок.
В случае, если исходный текст не соответствует синтаксическим правилам языка, необходимо корректно реагировать на некорректную цепочку лексем. В этом случае можно завершить синтаксический анализ и вывести сообщение об ошибке, либо попробовать за одну попутку синтаксического анализа найти как можно больше ошибок.

%TODO: описать мой обработчик

В ANTLR существуют следующие типы ошибок парсинга:
\begin{itemize}
\itemошибка распознавания токена (Lexer no viable alt); единственная существующая лексическая ошибка, обозначающая отсутствие правила для формирования токена из существующей лексемы.

%class # { int i; } — здесь такой лексемой является #.

\itemотсутствующий токен (Missing token); в этом случае ANTLR вставляет в поток токенов отсутствующий токен, помечает, что его не хватает, и продолжает парсинг.

%class T { int f(x) { a = 3 4 5; } } — здесь такой токен это } в конце;

\itemлишний токен (Extraneous token). Генератор помечает, что токен ошибочный и продолжает парсинг дальше.
%class T ; { int i; }

\itemнесовместимая входная цепочка (Mismatched input). При этом включается «режим паники», цепочка входных токенов игнорируется, а парсер ожидает токена из синхронизирующего множества.

%class T { int f(x) { a = 3 4 5; } }

\itemотсутствующая альтернатива (No viable alternative input). Данная ошибка описывает все остальные возможные ошибки парсинга.

%class T { int ; }

\end{itemize}
Для обработки ошибок используется класс ThrowingErrorListener, наследуемый от BaseErrorListener. BaseErrorListener предоставляет пустую имплементацию интерфейса ANTLRErrorListener. Реализация каждого метода по умолчанию ничего не делает, но может быть переписана в наследнике по мере необходимости. Для обработки синтаксических ошибок используется метод syntaxError, уведомляющий в какой строке и на какой позиции в строке возникла ошибка и ее причину.

На листинге \ref{lst:ErrorExample1} представлен пример тестового сценария с синтаксической ошибкой: на 9 строке после ключевого слова не указана текстовая инструкция. В этом случае ThrowingErrorListener должен сообщить о синтаксической ошибке (листинг \ref{lst:ErrorExampleRes1}).
\lstinputlisting[caption=Пример тестового сценария с синтаксической ошибкой, language=java,  firstline=1,  lastline=10 , label={lst:ErrorExample1}]{res/ErrorExample.txt}


\lstinputlisting[caption=Результат работы интерпретатора для тестового сценария с синтаксической ошибкой, language=java,  firstline=13,  lastline=14 , label={lst:ErrorExampleRes1}]{res/ErrorExample.txt}


В случае, если на вход подается тестовая спецификация, в которой указана инструкция, не объявленная в пользовательской библиотеке команд (листинг \ref{lst:ErrorExample2}), возникает исключение UndefinedInstructionException, сообщающее какая именно инструкция была не определена (листинг \ref{lst:ErrorExampleRes2}).

\lstinputlisting[caption=Пример тестового сценария необъявленной инструкцией, language=java,  firstline=18,  lastline=20, , label={lst:ErrorExampleInput2} ]{res/ErrorExample.txt}


\lstinputlisting[caption=Результат работы интерпретатора для тестового сценария с необъявленной инструкцией, language=java,  firstline=22,  lastline=23, label={lst:ErrorExampleRes2}]{res/ErrorExample.txt}



%TODO: add more info about defferent exceptions

\chapter{Экспериментальная часть }
\label{cExperiments}
%Рекомендуемый объем главы --- 5--20 стр.
%Название главы должно отражать ее содержание, например "Оценка эффективности вечного двигателя''.



\section{Тестирование}
%Проверка адекватности модели, сравнение с существующими аналогами, выбор
%представительного множества тестов, анализ результатов испытаний.

Для тестирования реализованного языка были разработаны Unit тесты. Модульное тестирование, оно же юнит-тестирование, позволяет проверить корректность отдельных модулей исходного кода программы.

% \ref{lst:label}

\lstinputlisting[caption=входные данные для теста testTwoInstructionsInTheSameLine, language=java,  firstline=2,  lastline=9 , label={lst:testTwoInstructionsInTheSameLine}]{res/testTwoInstructionsInTheSameLine.txt}

\lstinputlisting[caption=входные данные для теста testSetEmptyInstruction, language=java,  firstline=13,  lastline=22, label={lst:testTwoInstructionsInTheSameLine} ]{res/testTwoInstructionsInTheSameLine.txt}

Результат выполнения тестовых сценариев приведен на рисунке. %TODO add ref %
Сводная информация представлена в спецификации для разработанного синтаксического анализатора и результаты выполнения тестов (таблица \ref{tTestSpecification}). В первой колонке указано название теста, во второй ошибка, ожидаемая в результате выполнения синтаксического анализа. В третьей колонке указан статус теста: в случае, если тест пройден успешно указывается статус Passed, иначе -- Failed.



\begin{Table}{Тестовая спецификация реализации языка}{tTestSpecification}
\begin{tabular}{ | m{4cm} | m{5cm}| m{1cm} | }
\hline
\textbf{Название теста} & \textbf{Ожидаемое поведение} &\textbf{Статус теста}\\
\hline
PauseValule &line 2:8 mismatched input 'erf' expecting INTEGER &Passed\\
\hline
PauseNullValule& line 2:8 missing INTEGER at ']' & Passed \\
\hline
PauseGoodValPauseNullVal&line 3:8 missing INTEGER at ']' & Passed \\
\hline
SendEmptyInstructionEOF&line 3:6 missing TEXT at '' & Passed \\
\hline
SendEmptyInstruction & line 3:6 mismatched input '@Pause' expecting TEXT &Passed \\
\hline
SetEmptyInstruction& line 9:5 missing TEXT at 'NEWLINE'& Passed \\
\hline
TwoInstrInTheSameLine& line 8:23 extraneous input '@Pause' expecting {, TestCase} & Passed \\
\hline
InstructionIsNotDeclared&Instruction 'request [] in functional addressing mode' is undefined in the lib 'CommandLib' & Passed \\
\hline
\end{tabular}
\end{Table}





В результате тестирования выявлено, что интерпретатор работает корректно.
%\section{Примеры применения метода или программы}

\Chapter{Заключение }
%Рекомендуемый объем --- 2--4 стр.
%Содержит изложение итогов квалификационной работы в сопоставлении с общей
%целью и поставленными задачами. Формулировка суждения автора о научной
%новизне и практической ценности ВКР. Предложения по внедрению результатов,
%перспективы продолжения работы


%\addcontentsline{toc}{chapter}{bibname}
\bibliographystyle{gost71s}
\bibliography{bibliography}
%\bibliography{bibliography}


\end{document}