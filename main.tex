\documentclass[twoside]{report}
\usepackage[cp1251]{inputenc}
\usepackage[english,russian]{babel}
\usepackage[T2A]{fontenc}
\usepackage{spbstuthesis}
\usepackage{graphicx}
\usepackage{multirow}
\usepackage{amsmath}
\usepackage{subfigure}
\usepackage{appendix}
\usepackage{xcolor}
\usepackage{listings} 



\bachelor{Разработка и реализация языка описания сценариев тестирования автомобильных систем}{09.03.01 <<Информатика и вычислительная техника>>}{09.03.01\_06 <<Распределенные информационные системы>>}{43504/6}{А. А. Спасеева}{д.т.н., проф.}{ А. В. Самочадин}



\Abstract{Выпускная квалификационная работа посвящена разработке языка описания сценариев тестирования автомобильных систем. Проводится сравнительный анализ схожих по тематике инструментов.\\
Так же описываются принципы разработки языков и технических инструментов, выбранных для разработки.\\
Результат работы -- язык описания сценариев тестирования автомобильных систем, являющийся потенциально пригодным для внедрения на производстве.\\
%для бакалаврских, дипломных и магистерских работ

Клчевые слова: Предметно-ориентированный язык, функциональное тестирование, автомобильные системы.

}{The final qualifying work is devoted to the development of the...


}

\begin{document}
 
\sloppy
\maketitle
\task{A. A. Спасеевой}{
%для бакалаврских, дипломных и магистерских работ
\item Срок сдачи работы.
\item Исходные данные к проекту (работе).
\item Содержание расчетно-пояснительной записки (перечень подлежащих 
разработке вопросов).
\item Перечень графического материала с точным указанием обязательных 
чертежей.
\item Консультанты по проекту (с указанием относящегося к ним разделов 
проекта, работы).
}
%для бакалаврских, дипломных и магистерских работ
\makeabstract
\tableofcontents



%для бакалаврских, дипломных и магистерских работ
\Chapter{Список обозначений}
\begin{tabular}{ll}
UML& унифицированный язык моделирования\\
ECU&Electronic Control Unit\\
BDD& behaviour-driven development\\
ПО & программное обеспечение\\
TTD&test-driven development\\
DSL& Domain-specific language\\
AUTOSAR&Automotive Open System Architecture\\
БНФ&Форма Бэкуса-Наура\\
РБНФ&Расширенная форма Бэкуса-Наура\\
AST& Abstract syntax tree
\end{tabular}

%------------------------ВВЕДЕНИЕ-----------------------------
\Chapter{Введение}
С развитием автомобильной промышленности тестирование автомобильных систем стало неотъемлемой частью жизненного цикла разработки программного и аппаратного обеспечения. Современные автомобили включают множество встроенных систем для повышения уровня безопасности и комфорта водителей и пассажиров путем обеспечения функций, таких как адаптивный круиз-контроль, контроль давления в шине и др. 

Современные автомобили имеют несколько блоков управления (electronic control unit, ECU), связанных между собой внутримашинной сетью. Эти блоки взаимодейсвуют между собой через стандартные шинные архитектуры CAN, FlexRay, LIN и Ethernet. С развитием техники количество ECU в автомобильных системах стремительно растет, что приводит к созданию сложных стуктур сетей. К основным особенностям автомобильного программного обеспечения можно отнести:
\begin{itemize}
\item	надежность: автомобильные программные системы должны работать исключительно надежно в сложной сети ECU в течение всего срока эксплуатации автомобиля;
\itemфункциональная безопасность: такие функции, как антиблокировочная тормозная система и ESC, требуют безотказной работы, что определяет высокие требования к процессам разработки программного обеспечения и к самим программам;
\itemработа в режиме реального времени: быстрая реакция (от микросекунд до миллисекунд) на внешние события требует оптимизированных операционных систем и особой программной архитектуры;
\itemминимальное потребление ресурсов: любое дополнение вычислительных ресурсов или памяти увеличивает стоимость продуктов, что при миллионных тиражах выливается в немалые деньги;
\itemнадежная архитектура: автомобильное программное обеспечение должно выдерживать искажение сигналов и поддерживать электромагнитную совместимость;
\itemэлектронно-механическое управление замкнутого цикла.
\end{itemize}
Функциональные проверки безопасности автомобильных систем на программном уровне включают: 
\begin{itemize}
\itemФункциональное тестирование, с целью гарантировать, что программное обеспечение удовлетворяет требованиям высокого и низкого уровней.
\itemАнализ времени выполнения худшего сценария, для того чтобы гарантировать, что критические функции ПО выполняются достаточно быстро (такие как срабатывание подушек безопасности).
\itemСтруктурный анализ покрытия.
\end{itemize}


Для качественного тестирования автомобильных систем необходимо хорошо понимать, как устроен автомобиль в целом и его составляющие по отдельности. Однако, преставления о системе у инженеров и менеджеров зачастую очень сильно расходятся. Взаимодействие тестировщика, заказчика, менеджера, бизнес-аналитика и разработчика является неотъемлемой частью гибкой методологии разработки (Agile software development). 
В данной работе рассматривается разработка языка для функционального тестирования ПО автомобильных систем таким образом, чтобы тестовая документация была понятна всем участникам бизнес процесса. 
Для достижения взаимопонимания между всеми участниками процесса была создана практика «разработка, основанная на функционировании» (behaviour-driven development – BDD). 
В сфере автомобильных систем BDD подход мог бы сильно облегчить процесс разработки. 

%TODO: обзор глав

Работа организована следующим образом. В главе \ref{cReview} представлен 
обзор проблемы создания языка для описания тестовых сценариев тестирования автомобильных систем и обзор аналогов. Глава \ref{cDesign} содержит 
описание предлагаемого подхода к его построению. Вопросы его практической 
реализации рассмотрены в главе \ref{cImplementation}. Результаты 
экспериментального исследования его эффекивности приведены в главе 
\ref{cExperiments}. 

%------------Постановка задачи и обзор литературы -------------------
\chapter{Обзор литературы и постановка задачи }
\label{cReview}
%Рекомендуемый объем главы "--- 10--15 стр. 
%Название главы должно отражать ее содержание, например ``Проблема вечного 
%двигателя''.

%---------------------------ГЛАВА 1.1 ЦЕЛЬ И ЗАДАЧИ
\section{ Цель и задачи} Целью выпускной квалификационной работы является разработка domain specific языка для функционального тестирования автомобильных систем, который облегчит взаимодействие между тестировщиком, заказчиком, менеджером, аналитиками, разработчиками и предоставит функционал, необходимый для симуляции работы автомобильных сетей. Такой язык позволит достичь большего взаимопонимания между менеджерами, аналитиками и инженерами, что в свою очередь значительно упростит разработку ПО и повысит качество разрабатываемого продукта. 
Для достижения поставленной цели следует выполнить ряд задач:
\begin{itemize}
\itemИсследовать предметную область
\itemВыделить аналоги и сравнить их
\itemРазработать язык
\itemРеализовать язык
\itemПротестировать язык
\end{itemize}


%---------------------------ГЛАВА 1.2.	Обзор литературы
\section{ Обзор литературы}
Одно и то же оборудование, разрабатываемое для разных автомобильных компаний с различной внутренней архитертурой программного обеспечения при тестироввании ПО может рассматриваться в качестве «черного ящика». В этом случае тестируется функциональное поведение объекта. Под этой стратегией понимается создание тестов для тестового набора, основанных на технических требованиях и их спецификациях. 

В марте 2006 года Dan North предложил BDD методологию (behaviour-driven development), основанную на agile методологиях. BDD является своего рода расширением техники разработки программного обеспечения через тестирование (test-driven development, TTD). Идея BDD подхода была в том, что в процессе написания требования для разрабатываемого ПО аналитики должны описать тестовые сценарии таким образом, чтобы их смог понять и разработчик, и тестировщик. При этом тестовые сценарии состоят из набора заранее обговоренных предложений. 
В своей статье Dan North описал следующие BDD идеи:

\begin{itemize}
\itemНазвание тестового метода должно быть предложением. В этом случае хорошо разработанная документация будет понятна и бизнес пользователям и инженерам. 
\itemПростой шаблон делает тестовые методы более определенными. 
\itemВыразительное название очень помогает, когда тест обрушился.
\itemСлово «поведение» более полезное, чем «тест».
\itemМетодология BDD предоставляет «общий язык» для анализа. 
\itemПриемочные критерии должны быть выполняемыми.
\end{itemize}

Почти в то же время Эрик Эванс опубликовал книгу «Проблемно-ориентированное проектирование», в которой описал набор принципов и схем, направленных на создание оптимальных систем объектов. Его идея заключается в том, что для бизнеса удобно смоделировать систему, в которой будет определен единый язык (Domain specific language), основанный на бизнес области, такой, что бизнес словарь смогут использовать как менеджеры так и инженеры.  

Совместно Эрик Эванс и Dan North разработали шаблон для выявления приемочных критериев теста. Они разработали структуры тестовых сценариев, в которых каждый шаг определялся ключевым словом
\begin{itemize}
\item	Given – дано начальное условие
\item	When – происходит событие
\item	Then – проверка, что получены некоторые результаты
\end{itemize}

На основе вышеперечисленных принципов BDD был создан язык Gherkin – человеко-читаемый язык, используемый для описания поведения системы.

С точки зрения автомобильной индустрии, в которых функциональное тестирование ПО подразумевает достаточно нетривиальную задачу данный подход сильно облегчает взаимодействие между всеми бизнес участниками. Однако не существует инструмента облегчающего разработку документации, а как следствия взаимопонимания между менеджерами и инженерами и, в то же время, учитывающего особенности данной сферы. 

Возможность использовать единую всеми участниками модель предметной области позволяет значительно ускорить процесс проектирования ПО. Предметно-ориентированое программирование (Domain-driven design, DDD) основано на трех главных определениях:

\begin{itemize}
\item	Область (англ. domain, домен) — предметная область, к которой применяется разрабатываемое программное обеспечение.

\item	Модель (англ. model) — описывает отдельные аспекты области и может быть использована для решения проблемы.

\item	Язык описания — используется для единого стиля описания домена и модели.
\end{itemize}

Использование концепции моделирования системы с использованием единого языка, основанного на бизнес области таким образом, что словарь используется в разработке ПО может решить проблему взаимодействия участников бизнес процесса.

В 2003 году была создана Автомобильная Открытая Системная Архитектура (AUTOSAR, Automotive Open System Architecture). Это открытая архитектура, которая стандартизирует архитектуры ПО для автомобильных ECU и жизненный цикл разработки.  Сегодня в Autosar входят более 150 компаний, и в рамках этого партнерства разрабатывается архитектура ECU, базовое программное обеспечение, методология и стандартизованные интерфейсы для прикладного программного обеспечения.

Учитывая, что все системы стандартизированы, одну и ту же систему (например, лидары для автомобилей марок Diamler и Audi) можно протестировать использую одни и те же инструменты. Однако, среди современных средств для тестирования программных систем нет специализированных под специфические нужды автомобильной промышленности, и при этом позволяющих разрабатывать спецификации на человеко-читаемом языке для реализации BDD подхода.

С расширением областей применения вычислительной техники возникла необходимость в новом — проблемно-ориентированном языке (domain-specific language, DSL), позволяющем в определенной области использовать специфичные обозначения и термины. Такие языки обеспечивают пользователям возможность коротко и четко сформулировать задачу и получить результаты в необходимой для них форме. 


Хорошо разработанный DSL язык должен быть основан на следующих принципах (Debasish, G. 2011 DSLs in Action, Manning Publications):

•	Язык зеркально отображает артефакты предметной области.

•	Язык должен использовать общий словарь предметной области. Словарь становится катализатором для лучшей связи между разработчиками и бизнес-пользователями.

•	Имплементация языка должна быть абстракцией. В язык не должно быть точных фрагментов имплементации языка. 

Использование проблемно-ориентированный языка позволит решить проблему разработки тестовой документации понятной всем участникам бизнес процесса с учетом специфики автомобильной промышленности.


%----------------------------------------ГЛАВА 1.3.	Анализ существующих инструментов для тестирования
\section{Анализ существующих инструментов для тестирования}
%Описание реального объекта исследования, используемых методов исследования,
%техническое и организационное  содержание работ.
%----------------------------------------------------1.3.1.	Выделение критериев сравнения
\subsection{Выделение критериев сравнения}
Требования к разрабатываемой системе
\begin{itemize}
\itemАрхитектура тестов, разрабатываемых с помощью языка, должна быть событийно-управляемая (Event based).  
\itemЯзык должен быть проблемно-ориентированным
\itemЯзык должен позволять использовать BDD подход.
\end{itemize}

\subsection{Обзор аналогов}

\begin{itemize}
  \item CAPL (Communication Access Programming Language)
  
Компания Vector, разрабатывающая программные инструменты для работы с коммуникационными сетями, основывающихся на шинах CAN, LIN, FlexRay, Ethernet и др., используемыми в автомобильной промышленности создала программный пакет для разработчиков: CANoe. Этот инструмент поддерживает симуляцию работы сетей, предоставляет диагностические инструменты и т.д. Данный пакет используется большинством OEM-производителей и поставщиков автомобильных компонентов. В среде CANoe есть возможность разрабатывать тестовые сценарии на языке CAPL (Communication Access Programming Language). 

CAPL - процедурный язык, на котором выполнение блоков программы управляются событиями. Эти блоки программы упоминаются как событие процедуры.

С помощью CAPL можно описать тесты, полностью покрывающие функциональные требования АС. Однако данный язык является Си подобным, достаточно трудным для понимания менеджерами и аналитиками.



\item CCDL
  
Еще одним языком для описания тестовых спецификаций в автомобильной сфере является CCDL. Это язык тестовых спецификаций для тестирования, основанном на требованиях. Предоставляет высокоуровневый язык тестирования. CCDL может использоваться для автоматизированного black box тестирования. Однако, спецификации содержат в себе программный код, непонятный для части бизнес участников. 

\begin{figure}[h]
\center{\includegraphics[width=\linewidth]{res/CAPL-EX}}
\caption{Тестовый сценарий на языке CCDL}
\label{fig:image}
\end{figure}


\item Cucumber

Cucumber – это фреймворк, реализующий подход BDD. В Cucumber для разработки тестов используется Gherkin-нотация. Она определяет набор ключевых слов и структуру теста. Программная реализация шагов отделена от теста, что очень удобно для бизнеса. Однако для создания полной domain specific модели АС необходимо каждый раз заново реализовывать протокол коммуникации с тестовым оборудованием. 

\begin{figure}[h]
\center{\includegraphics[width=\linewidth]{res/CUCUMBER-EX-1}}
\caption{Тестовая спецификация Cucumber}
\label{fig:image}
\end{figure}

\begin{figure}[h]
\center{\includegraphics[width=\linewidth]{res/CUCUMBER-EX-2}}
\caption{Реализация шага Cucumber}
\label{fig:image}
\end{figure}


\end{itemize}

\subsection{Результаты}
Из вышеперечисленных инструментов для тестирования ПО видно, что ни один из них не удовлетворяет требованиям. Таким образом существует необходимость в создании domain specific языка для функционального тестирования, который объединит в себе принципы BDD и функционал, необходимый для симуляции работы автомобильных сетей CAN, LIN, Ethernet. Наличие такого языка значительно упростит разработку ПО и повысит качество разрабатываемого продукта. 

%------------------------Уточненные требования к работе  TODO
\section{    Уточненные требования к работе }
Окончательная постановка задачи с явным отсечением лишнего 
(чужого, нереализуемого и т.д.)

%------------------------------------Теоретическая часть. Разработка языка
\chapter{Теоретическая часть}
\label{cDesign}
%Рекомендуемый объем главы --- 10--25 стр.
%Название главы должно отражать ее содержание, например ``Построение вечного двигателя на основе технологий объектно-ориентированного программирования''.
%Глава должна содержать
%структурированное описание использованного метода, подхода, математического аппарата, 
%разработанного алгоритма; обоснование решений, доказательство утверждений, 
%аналитические оценки. Основное содержание теоретической части должны 
%составлять результаты, полученные автором. При необходимости, описание 
%используемых классических методов должно быть приведено в главе 

Разрабатываемый язык описания сценариев тестирования автомобильных систем должен быть проблемно-ориентированным, при этом прост в использовании и изучении, а так же предоставлять возможность разрабатывать сценарии не только инженерами, но и бизнес-аналитиками. 


\section{    Описание синтаксиса языка }
Существуют три основных метода описания синтаксиса языков программирования: формальные грамматики, формы Бэкуса-Наура и диаграммы Вирта.

Формальной грамматикой называется четверка вида:  G = (VT, VN, P, S), 

где где VN - конечное множество нетерминальных символов грамматики,
VT - множество терминальных символов грамматики 
Р – множество правил вывода грамматики,
S – начальный символ грамматики.

Для записи правил вывода с одинаковыми левыми частями вида a-> b1, a->b2, ..., a->bn   используется сокращенная форма записи a-> b1|b2|...|bn.

%БНФ

Во второй половине 20-го века Джон Брэкус и Ноам Хомски независимо друг от друга создали форму записи, которая в последствии стала методом формального описания синтаксиса языков. 
Форма Бэкуса-Наура (БНФ) – формальная система описания синтаксиса, используемая для описания контекстно-свободных грамматик, в которой одни синтаксические абсстракции последовательно определяются через другие абстракции. Для описания синтаксических структур форма БНФ исползует абстракции.  

Форма БНФ является порождающим устройством для определения языков. С помощью последовательности правил создаются преждложения языка. Создание предложений называется выводом.
Вывод должен начинаться с начального символа start symbol. Сентенциальная форма грамматики - это строка, которая может быть выведена из стартового символа. Предложение (сентенция) грамматики - это сентенциальная форма, состоящая только из терминальных символов. Язык L(G) грамматики - это множество всех ее предложений.  

Метаязык, предложенный Бэкусом и Науром, использует следующие обозначения:
\begin{itemize}
\itemсимвол «::=» отделяет левую часть правила от правой (читается: «определяется как»);
\itemнетерминалы обозначаются произвольной символьной строкой, заключенной в угловые скобки «<» и «>»;
\itemтерминалы - это символы, используемые в описываемом языке;
\itemправило может определять порождение нескольких альтернативных цепочек, отделяемых друг от друга символом вертикальной черты «|» (читается: «или»).
\end{itemize}


%РБНФ
Из-за некоторых незначительных неудобств в БНФ Никлаус Вирт предложил свой вариант расширенной формы Бэкуса-Наура (РБНФ, расширенная Бэкус — Наурова форма). Эти расширения не увеличивают описательну силу БНФ, а упрощают чтение и использование такой формы.  

Для повышения удобства и компактности описаний, в РБНФ вводятся следующие дополнительные конструкции (метасимволы):
\begin{itemize}
\itemквадратные скобки «[» и «]» означают, что заключенная в них синтаксическая конструкция может отсутствовать;
\itemфигурные скобки «\{» и «\}» означают повторение заключенной в них синтаксической конструкции ноль или более раз;
\itemсочетание фигурных скобок и косой черты «\{/» и «/\}» используется для обозначения повторения один и более раз;
\itemкруглые скобки «(» и «)» используются для ограничения альтернативных конструкций.
\end{itemize}

%Диаграммы Вирта

Синтаксическими графами называются ориентированные графы, на которых представляется информия о правилах форм БНФ и РБНФ. Так же их называют синтаксическими диаграммами или синтаксическими схемами.
При построении диаграмм учитывают следующие правила:
\begin{itemize}
\itemкаждый графический элемент, соответствующий терминалу или нетерминалу, имеет по одному входу и выходу, которые обычно изображаются на противоположных сторонах;
\itemкаждому правилу соответствует своя графическая диаграмма, на которой терминалы и нетерминалы соединяются посредством дуг;
\itemальтернативы в правилах задаются ветвлением дуг, а итерации - их слиянием;
\itemдолжна быть одна входная дуга (располагается обычно слева или сверху), задающая начало правила и помеченная именем определяемого нетерминала, и одна выходная, задающая его конец (обычно располагается справа и снизу);
\itemстрелки на дугах диаграмм обычно не ставятся, а направления связей отслеживаются движением от начальной дуги в соответствии с плавными изгибами промежуточных дуг и ветвлений.
\end{itemize}

%Компилируемый или интерпретируемый?
\section{Общая структура}
Существует два главных вида языков программирования: компилируемый и интерпретируемый. 
	Компилятор выясняет все, что должна выполнить программая, превращает иснтрукции в машинный код и сохраняет его, чтобы выполнить позже. 
	Интрепретатор проходит всю программу строчку за строчкой и тут же выполняет.
	
Технически любой язык может быть, как компилируемым так и интерпретируемым. Обычно компилируемй язык выбирают, если в программе важна скорость работы. Интерпретируемый же язык более гибкий. 

В случае разработки интерпретатора стадии разработки можно разбить на следующие этапы: 

\begin{itemize}
\itemЛексический анализ – разбор исходного кода на токены. Этот этап выполняется лексером.
\itemСинтаксический анализ – сбор токенов в абстрактное синтаксическое дерево (AST). Данный этап выполняется синтаксическим анализатором (парсером).
\itemсемантический анализ;
\itemИсполенение AST 
\end{itemize}



Естественные языки и искусственные, вне зависимости от их происхождения, представляют собой совокупность строк, состоящих из символа некоторого алфавита. Предложения или утверждения – это строки, состоящие из символов языка. Какие именно утверждения существуют в языке определяют синтаксические правила. 

%---------------------------------------ЛЕКСИЧЕСКИЙ АНАЛИЗ
\subsection {Лексичекий анализ}
Первым шагом в разработке языков зачастую язвляется лексический анализ – процесс аналитического разбора входной последовательности символов на лексемы, с целью получения на выходе идентифицированных последовательностей, называемых токенами. Токен – это малая единица языка. Токен может быть именем переменной или функции, оператором или числом. 

Предполагается, что лексер беред входную строку, содержащую файлы с исходным кодом на разрбатываемом языке и разделяет его на список токенов. Лексер может выполнять такие задачи, как удаление комментариев, определение чисел и т.д.

ЛА необязательный этап, но желательный так как:

1) замена идентификаторов, констант, ограничителей и служебных слов лексемами делает программу более удобной для дальнейшей обработки.

2) Лексический анализатор уменьшает длину программы, устраняя из ее исходного представления комментарии и несущественные пробелы.

3) если будет изменена кодировка в исходном представлении программы, то это отразится только на лексическом анализаторе.

В процедурных языках лексемы обычно делятся на классы:  служебные слова и ограничители.


Входные данные ЛА - текст транслируемой программы на входном языке.

Выходные данные ЛА - файл лексем в числовом представлении. %TODO добавить листинг BddLexer.tokens





\subsection {Синтаксический анализ}
%синтаксический анализ
Синтаксический анализ – это процесс сопоставления линейной последовательности лексем (слов, фраз) языка с его формальной грамматикой. Результатом обычно является синтаксическое дерево. Обычно применяется совместно с лексическим анализом. Синтаксический анализатор— это программа или часть программы, выполняющая синтаксический анализ, то есть распознавание входной информации. При этом входные данные преобразуются к виду, пригодному для дальнейшей обработки. Этот вид обычно представляет собой формальную модель входной информации на языке последующего процесса обработки информации.

Во время парсинга входной текст преобразуется в стуктуру данных, которая отражает синтаксичекскую структуру входной последовательности и подходит для последующей обработки. Как правило синтаксическая структура представляется в виде дерева зависимостей. 

Существуют следующие алгоритмы синтаксического анализа: 
\begin{itemize}
\itemНисходящий (англ. top-down) – это такой такой анализ, в котором продукции грамматики раскрываются, начиная со стартового символа, до получения требуемой последовательности лексем.
\itemВосходящий (англ. bottom-up) – это такой такой анализ, в котором продукции восстанавливаются из правых частей, начиная с токенов-лексем и кончая стартовым символом.
\end{itemize}

Нисходящий анализ (метод рекурсивног оспуска) является наиболее эффективным методом синтаксического анализа. В его основе лежит левосторонний разбор строки языка. Исходной сентенциальной формой является начальный символ грамматики, а целевой – заданная строка языка. На каждом шаге разбора правило грамматики применяется к самому левому нетерминалу сентенции. Данный процесс соответствует построению дерева разбора цепочки сверху вниз (от корня к листьям).

%ДЕРЕВЬЯ СИНТАКСИЧЕСКОГО АНАЛИЗА


\subsection {Семантический анализ}
В ходе семантического анализа проверяются отдельные правила записи исходных программ, которые не описываются КС-грамматикой. Эти правила носят контекстно-зависимый характер, их называют семантическими соглашениями или контекстными условиями.

Пользовательские инструкции, используемые в тестовых сценариях должны быть заранее обьявлены пользователями в специальной бибилиотеке. Ключевое слово должно отражать смысл инструкции: Send- для отправки пакета, Recieve - для получания пакета и т.д. 

В теле метода  сооветствующей инструкции должны быть реализованы шаги отправки, получения пакетов и т.д. в зависимости от аннотации. Для того, чтобы определить метод, который должен быть выполнен при вызове заданной текстовой инструкции, а так же приведения типов пользовательских параметров можно использовать рефлексию.

Рефлексия (от лат. reflexio — обращение назад) — это механизм исследования данных о программе во время её выполнения. Рефлексия позволяет исследовать информацию о полях, методах и конструкторах классов. 

Механизм рефлексии позволяет обрабатывать типы, отсутствующие при компиляции, но появившиеся во время выполнения программы. Возможность использования рефлексии реализована в Java с помощью Reflection API.  

\subsection {Симуляция работы сетей}

рассказать о шине CAN в промышленной автоматизации, eternet, fleaxray? немного о их пакетах и что нужно для тестирования? 


% ------------------------------------------------ГЛАВА Реализационная часть
\chapter{Реализационная часть}
\label{cImplementation}
%Рекомендуемый объем главы --- 10-30 стр.
%Название главы должно отражать ее содержание, например ``Архитектура вечного двигателя''.
%В главе должно быть описание этапов разработки технического решения задачи. Следующий пример
%приведен для работ, связанных  с проектированием и реализацией 
%программного продукта.


Задача построения языка довольна трудозатратная. Однако существуют программные инструменты, помогающие сделать его меньше и проще. Для этого был разработан следующий инструментарий для создания компиляторов: генераторы лексических анализаторов (сканеров), генераторы синтаксических анализаторов (парсеров), автоматические генераторы кода.

Для реализации языка было выбрано «еще одно средство распознавания языков» ANTLR4 (ANother Tool for Language Recognition). Это генератор нисходящих анализаторов (парсеров) для формальных языков. Он преобразует контекстно-свободную грамматику в форме РБНФ в программу на Java, C++, JavaSript, Go. Python и Go. 

ANTLR4 удобен для работы с AST, является свободным программным обеспечением, предоставляет сообщение об ошибках и восставновление после них, а так же предоставляет плагины для Eclipse и IntelliJ IDEA, что позволяет удобно создавать и отлаживать грамматики. Интерпретатор реализован на языке java.

%-------------------------------------ЛЕКСЕР
\section{ Лексер}
DSL для описания тестовых сценариев автомобильных систем должен иметь следующие характерные инструкции (предложения):
\begin{itemize}
\itemОтправить фрейм, сигнал или набор данных по UDS протоколу на тестируемое ПО
\itemПолучить фрейм, сигнал или набор данных по UDS протоколу от тестируемого ПО
\itemСделать паузу между инструкиями, чтобы тестируемое ПО успело сформировать и отправить необходимый пакет
\itemВыполнять шаги определенное количество раз, т.к. многие системы имеют алгоритмы со счетчики, которые можно выполнить определенное количесво раз. Зачастую значения таких счетчиков измеряются сотнями и даже тысячами шагов. При удачной группировке этих шагов количество строк тестового сценария можно сократить в десятки раз, поместив из в цикл.
\itemВыполнять определенные действия по событию (триггер).
\itemУстановить значение отправляемого сигнала
\itemПроверить полученное значение сигнала
\end{itemize}

При этом набор иструкций команды, состоящие из аналитиков, тестировщиков и разработчиков должны определять сами, так как процессе разработки автомобильного ПО могут выявляться свойства, специфичные для того или иного программного продукта. У пользователей должна быть позможность описать сценарии с иcпользованием специфичных терминов (рычаги у рулевой колонки, расстояние у лидара и т.д).
 Предполагается, что пользователи сами определяют ограниченный набор шагов, необходимых для описания тестовых сценариев, а тестировщиик набор шагов для каждой инструкции. 
 
Допустим, пользователи обпределили следующий ограниченный набор команд: «Отправить запрос ‘запрос’», «Получить ответ ‘ответ’». При этом формат запроса и ответа является проектно-специфичным, а значит при описани любого шага должна быть возможность описывать кастомизированные параметры. Добиться этого можно, выделив параметр в отдельную лексему. 

Было принято решение, что синтаксис разрабатываемого языка будет иметь аналогичные с Gherkin ключевые слова, возможность описывать сценарии на языке, привычном пользователю, будь то русский или английский. 
Из вышеуказаного можно определить следующий набор ключевых слов с которых должен начинаться любой шаг сценария:  Send, Set, Check, Receive, Pause, Trigger, When, Repeat.

В свою очередь шаги группируются в тестовые сценарии, которых в тестовой спецификации может быть несколько.

При этом для удобства пользователя все эти лексемы языка должны быть регистронезависимы. 
К сожалению, в ANTLR нет поддержки регистронезависимых токенов, и для токенов приходится использовать следующую запись с использованием фрагментных токенов, которые используются для построения реальных токенов: 

fragment S: [sS];


\lstinputlisting[caption=Ключевые слова, language=java,  firstline=22,  lastline=36 ]{res/BddLexer.g4}


%---------------------------------ПАРСЕР
\section{Парсер}

Для описания синтаксической структуры языка нужно определить порядок записи:
\begin{itemize}
\itemПредложений в тексте;
\itemФраз в предложении;
\itemЛексем и фраз в более общих фразах.
\end{itemize}

Для разрабатываемого языка необходимы такие синтаксические правила как текст инструкции и кастомизированный параметр. При этом текст может содержать пробелы, любые символы английского и русского языков, а так же любые другие символы, кроме символов, обозначающих начало и конец кастомизированного параметра, а так же служебный символ «@», обозначающий начало ключевого слова. 

Синтаксические правила одного шага можно описать следующим образом:

\begin{itemize}
\itemШаг должен начинаться с ключевого символа, определяемого служебным символом “@”
\itemШаг не может начинаться с пользовательского параметра
\itemШаг может начинаться с любого символа
\itemШаг может иметь сколь угодно много параметров
\end{itemize}

TODO: описать синтаксические правила шагов и сценария в целом


По описанным  правилам ANTLR генерирует файлы для распознания. 
BddParser.java - это описание класса парсера, то есть синтаксического анализатора, отвечающего грамматике BddParser. 
BddLexer.java -это описание класса лексера, или лексического анализатора, отвечающего грамматике 

BddParser.tokens, BddLexer.tokens — это вспомогательные классы, которые содержат информацию о токенах


BddParserVisitor.java, BddParserListener.java, BddParserBaseListener   — это интерфейсы и классы , содержащие описания методов, которые позволяют выполнять определенный действия при обходе синтаксического дерева




  
%-------------------------------Использование грамматики
\section{Использование грамматики}

Для использования разработанного парсера ANTLR4 представляет возможность сгенерировать два паттерна проектирования: Visitor (посеттель) и Listener(слушатель). Каждый из них предполагает анализ определенного подмножества узлов дерева разбора. Узлы дерева разбора, не являющиеся листьями, соответствуют каким-либо синтаксическим правилам грамматики. При анализе узлов дерева разбора нужно обращаться к дочерним узлам, соответствующим фрагментам исходного правила. Причем обращаться можно как к отдельным узлам, так и к группам узлов. Следовательно важным условием создания хорошей грамматики является возможность интуитивно простой доступ к любой части правила. ANTLR4 предоставляет такие сущности как альтернативные и элементарные метки. Альтернативные метки позволяют разбить сложное правило на альтернативные фразы и обрабатывать каждую фразу отдельно.  
В нашем случае правило инструкции можно разбить на следующие альтервативные метки:  
\lstinputlisting[caption= альтервативные метки синтаксического правила instruction,language=java,  firstline=11, 	 lastline=16 ]{res/BddParser.g4}


Элементными метками помечаются отдельные нетерминалы или последовательности терминалов. Они предоставляют доступ к содержимому контекста правила в виде поля с заданным именем. Таким образом, вместо вычисления (извлечения) отдельного элемента содержимого некоторого контекста достаточно просто обратиться к такой элементной метке.

В реализации интерпретатора используется паттерн Listener. При обходе абстрактного синтаксического дерева интерпретатор находит очередную нотированную инструкцию, с помощью рефлексии находит метод, аннотированный соотвествующим ключевым словом и добавляет ее в список необходимых для выполнения. При этом инструкция должна быть заранее определена пользователем в библиотеке инструкций. Во время семантического анализа все параметры пользовательских параметров приводятся к типам, объявленным в параметрах метода. Методы инcтрукций могут принимать параметры следующх типов: boolean, byte, short, integer, long, float, double, String, Enum. 

При завершении обхода AST инструкции поочередно выполняются в том порядке, в котором были заданы в тестовой спецификации. 

\lstinputlisting[caption=Пример реализации пользовательской инструкции с аннотацией Send,language=java]{res/annotatoinExample.txt}

Для реализации функционала симуляции автомобильных сетей используется XL-Driver-Library. XL-Driver-Library -- это универсальный программный интерфейс, позволяющий получить доступ к интерфейсам апаратных средств Vector. Он поддерживает следующие шины: 
\begin{itemize}
\item CAN / CAN FD
\item LIN
\item FlexRay
\item Automotive Ethernet
\item MOST
\item ARINC
\end{itemize}

XL-Driver-Library предоставляет общие и шинно-специфичные методы, которые облегчают управлять интерфейсами шины от Vector. Каналы  и порты управляются общими методами. Шинно-специфичные методы используются, чтобы настроить сетевые узлы и послать или получить сообщения.  XL-Driver-Library позволяет эффективно использовать интерфейсы шины в пользовательских приложениях. Особенно полезно это при реализации специализированных иструментов, которые адаптированы к автоматизированному рабочему месту и его окружению, с целью увеличения производительности. 
По словам производителей данная библиотека может быть использована при создании инструментов тестирования для тестового оборудования автомобильных систем. 

Для разработки XL Driver Library приложений требуется подключить динамческие бибилотеки, которые находятся в открытом доступе на сайте компании Vector. необходимые методы реализованы на языке С, поэтому для доступа к методам через java был реализован класс JNIVxlApi.java c использованием  механизма JNI. 

Java Native Interface (JNI) — стандартный механизм для запуска кода, под управлением виртуальной машины Java (JVM), который написан на языках С/С++ или Ассемблера, и скомпонован в виде динамических библиотек, позволяет не использовать статическое связывание. Это даёт возможность вызова функции С/С++ из программы на Java, и наоборот.

%----------------------Архитектура системы
%\section{Архитектура системы}
%Псевдокоды или блок-схемы основных алгоритмов, основные структуры данных  и др.

Ниже представлена диаграмма классов интерпретатора.



\begin{figure}[h]
\center{\includegraphics[width=\linewidth]{res/ClassDiagram}}
\caption{Диаграмма классов}
\label{fig:image}
\end{figure}


%------------------------Интерфейс системы
%\section{Интерфейс системы}
%\label{sSpec}
%Интерфейс пользователя, модульная структура, API
%\section{Особенности реализации}
%Использованные инструментальные средства, приемы программирования, 
%технические решения, связанные с ограничениями аппаратных или программных 
%средств.  


%--------------------------------------Обработчик ошибок
\section{Обработчик ошибок}
Важной способностью каждого парсера является обработка ошибок.
В случае, если исходный текст не соотвествует синтаксическим правилам языка, небоходимо корректно реагировать на некорректную цепочу лексем. В этом случае можно завершить синтаксический анализ и вывести сообщение об ошибке, либо попробовать за одну попутку синтаксического анализа найти как можно больше ошибок. 

%TODO: описать мой обработчик 

В ANTLR существуют следующие типы ошибок парсинга:
\begin{itemize}
\itemошибка распознавания токена (Lexer no viable alt); единственная существующая лексическая ошибка, обозначающая отсутствие правила для формирования токена из существующей лексемы.

%class # { int i; } — здесь такой лексемой является #.

\itemотсутствующий токен (Missing token); в этом случае ANTLR вставляет в поток токенов отсутствующий токен, помечает, что его не хватает, и продолжает парсинг.

%class T { int f(x) { a = 3 4 5; } } — здесь такой токен это } в конце;

\itemлишний токен (Extraneous token). Генератор помечает, что токен ошибочный и продолжает парсинг дальше.
%class T ; { int i; }

\itemнесовместимая входная цепочка (Mismatched input). При этом включается «режим паники», цепочка входных токенов игнорируется, а парсер ожидает токена из синхронизирущего множества. 

%class T { int f(x) { a = 3 4 5; } }

\itemотсутствующая альтернатива (No viable alternative input). Данная ошибка описывает все остальные возможные ошибки парсинга.

%class T { int ; }

\end{itemize}
Для обработки ошибок используется класс ThrowingErrorListener, наследуемый от BaseErrorListener. BaseErrorListener предоставляет пустую имплементацию интерфейса  ANTLRErrorListener. Реализация каждого метода по умолчанию ничего не делает, но может быть переписана в наследнике по мере необходимости. Для обработки синтаксических ошибок используется метод 	syntaxError, уведомляющий в какой строке и в на какой позиции в строке возникла ошибка и ее причину. 

Ниже представлен пример тестового сценария с синтаксической ошибкой: на 9 строке после ключевого слова не указана текстовая инструкция. В этом случае ThrowingErrorListener должен сообщить о синтаксической ошибке (листинг 3.4)
\lstinputlisting[caption=Пример тестового сценария с синтаксической ошибкой, language=java,  firstline=1,  lastline=10 ]{res/ErrorExample.txt}


\lstinputlisting[caption=Результат работы интерпретатора для тестового сценария с синтаксической ошибкой, language=java,  firstline=13,  lastline=14]{res/ErrorExample.txt}


В случае, если на вход подается тестовая спецификация, в окторой указана инструкция, не объявленая в пользовательской библиотеке команд, возникает исключение UndefinedInstructionException, сообщающее какая именно инструкция была неопределена.

\lstinputlisting[caption=Пример тестового сценария необъявленной инструкцией, language=java,  firstline=18,  lastline=20 ]{res/ErrorExample.txt}


\lstinputlisting[caption=Результат работы интерпретатора для тестового сценария с необъявленной инструкцией, language=java,  firstline=22,  lastline=23]{res/ErrorExample.txt}



%TODO: add more info about defferent exceptions

\chapter{Экспериментальная часть }
\label{cExperiments}
%Рекомендуемый объем главы --- 5--20 стр.
%Название главы должно отражать ее содержание, например ``Оценка эффективности вечного двигателя''.



\section{Тестирование и испытание метода или программы}
%Проверка адекватности модели, сравнение с существующими аналогами, выбор 
%представительного множества тестов, анализ результатов испытаний.

Для тестирования реализованного языка были разработа Unit тесты. Модульное тестирование, оно же юнит-тестирование, позволяет проверить корректность отдельных модулей исходного кода программы. 

\lstinputlisting[caption=входные данные для теста testTwoInstructionsInTheSameLine, language=java,  firstline=2,  lastline=9 ]{res/testTwoInstructionsInTheSameLine.txt}

\lstinputlisting[caption=входные данные для теста testSetEmptyInstruction, language=java,  firstline=13,  lastline=22 ]{res/testTwoInstructionsInTheSameLine.txt}


Ниже представлена спецификация для разработанного синтаксического анализатора и результаты выполнения тестов


%
% Please add the following required packages to your document preamble:
% \usepackage{booktabs}
% \usepackage{graphicx}
\begin{table}[]
\resizebox{\textwidth}{!}{%
\begin{tabular}{@{}lllll@{}}
\begin{tabular}[c]{@{}l@{}}Входной\\ текст\end{tabular}                       & \begin{tabular}[c]{@{}l@{}}Ожидаемое\\ поведение\end{tabular} & Статус    &  &  \\
@Pause [erf] ms                                                               & line 1:8 mismatched input 'erf' expecting INTEGER             & выполнено &  &  \\
@Pause [] ms                                                                  & line 1:8 missing INTEGER at ']'                               & выполнено &  &  \\
\begin{tabular}[c]{@{}l@{}}@Pause [2] ms\\ @Pause [] ms\end{tabular}          & line 2:8 missing INTEGER at ']'                               & выполнено &  &  \\
\begin{tabular}[c]{@{}l@{}}@Pause [2] ms\\ @Send\end{tabular}                 & line 2:6 missing TEXT at '<EOF>'                              & выполнено &  &  \\
\begin{tabular}[c]{@{}l@{}}@Pause [2] ms \\ @Send  @Pause [2] ms\end{tabular} & line 2:6 mismatched input '@Pause' expecting TEXT             & выполнено &  & 
\end{tabular}%
}
\end{table}

В результате тестирования выявлено, что интерпретатор работает корректно.

%\section{Примеры применения метода или программы}

\Chapter{Заключение }
%Рекомендуемый объем --- 2--4 стр.
%Содержит изложение итогов квалификационной работы в сопоставлении с общей 
%целью и поставленными задачами. Формулировка суждения автора о научной 
%новизне и практической ценности ВКР. Предложения по внедрению результатов, 
%перспективы продолжения работы 



\bibliographystyle{gost71s}
%\bibliography{bibliography}                              


\end{document}