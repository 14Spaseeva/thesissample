\documentclass[twoside]{report}
\usepackage[cp1251]{inputenc}
\usepackage[english,russian]{babel}
\usepackage[T2A]{fontenc}
\usepackage{spbstuthesis}
\usepackage{graphicx}
\usepackage{multirow}
\usepackage{amsmath}
\usepackage{subfigure}
\usepackage{appendix}
\usepackage{xcolor}
\usepackage{listings} 



\bachelor{Разработка и реализация языка описания сценариев тестирования автомобильных систем}{09.03.01 <<Информатика и вычислительная техника>>}{09.03.01\_06 <<Распределенные информационные системы>>}{43504/6}{А. А. Спасеева}{д.т.н., проф.}{ А. В. Самочадин}



\Abstract{
%для бакалаврских, дипломных и магистерских работ
Краткая характеристика всего документа,  основной результат работы, список 
ключевых слов
}{Brief description of the work, main result, keywords}

\begin{document}
 
\sloppy
\maketitle
\task{A. A. Спасеевой}{
%для бакалаврских, дипломных и магистерских работ
\item Срок сдачи работы.
\item Исходные данные к проекту (работе).
\item Содержание расчетно-пояснительной записки (перечень подлежащих 
разработке вопросов).
\item Перечень графического материала с точным указанием обязательных 
чертежей.
\item Консультанты по проекту (с указанием относящегося к ним разделов 
проекта, работы).
}
%для бакалаврских, дипломных и магистерских работ
\makeabstract
\tableofcontents



%для бакалаврских, дипломных и магистерских работ
\Chapter{Список обозначений}
\begin{tabular}{ll}
АБГШ& Аддитивный белый гауссовский шум\\
UML& унифицированный язык моделирования\\
EPS& Encapsulated Postscript
\end{tabular}

%------------------------ВВЕДЕНИЕ-----------------------------
\Chapter{Введение}
С развитием автомобильной промышленности тестирование автомобильных систем стало неотъемлемой частью жизненного цикла разработки программного и аппаратного обеспечения. Современные автомобили включают множество встроенных систем для повышения уровня безопасности и комфорта водителей и пассажиров путем обеспечения функций, таких как адаптивный круиз-контроль, контроль давления в шине и др. 

Современные автомобили имеют несколько блоков управления (electronic control unit, ECU), связанных между собой внутримашинной сетью. Эти блоки взаимодейсвуют между собой через стандартные шинные архитектуры CAN, FlexRay, LIN и Ethernet. С развитием техники количество ECU в автомобильных системах стремительно растет, что приводит к созданию сложных стуктур сетей. К основным особенностям автомобильного программного обеспечения можно отнести:
\begin{itemize}
\item	надежность: автомобильные программные системы должны работать исключительно надежно в сложной сети ECU в течение всего срока эксплуатации автомобиля;
\itemфункциональная безопасность: такие функции, как антиблокировочная тормозная система и ESC, требуют безотказной работы, что определяет высокие требования к процессам разработки программного обеспечения и к самим программам;
\itemработа в режиме реального времени: быстрая реакция (от микросекунд до миллисекунд) на внешние события требует оптимизированных операционных систем и особой программной архитектуры;
\itemминимальное потребление ресурсов: любое дополнение вычислительных ресурсов или памяти увеличивает стоимость продуктов, что при миллионных тиражах выливается в немалые деньги;
\itemнадежная архитектура: автомобильное программное обеспечение должно выдерживать искажение сигналов и поддерживать электромагнитную совместимость;
\itemэлектронно-механическое управление замкнутого цикла.
\end{itemize}
Функциональные проверки безопасности автомобильных систем на программном уровне включают: 
\begin{itemize}
\itemФункциональное тестирование, с целью гарантировать, что программное обеспечение удовлетворяет требованиям высокого и низкого уровней.
\itemАнализ времени выполнения худшего сценария, для того чтобы гарантировать, что критические функции ПО выполняются достаточно быстро (такие как срабатывание подушек безопасности).
\itemСтруктурный анализ покрытия.
\end{itemize}


Для качественного тестирования автомобильных систем необходимо хорошо понимать, как устроен автомобиль в целом и его составляющие по отдельности. Однако, преставления о системе у инженеров и менеджеров зачастую очень сильно расходятся. Взаимодействие тестировщика, заказчика, менеджера, бизнес-аналитика и разработчика является неотъемлемой частью гибкой методологии разработки (Agile software development). 
В данной работе рассматривается разработка языка для функционального тестирования ПО автомобильных систем таким образом, чтобы тестовая документация была понятна всем участникам бизнес процесса. 
Для достижения взаимопонимания между всеми участниками процесса была создана практика «разработка, основанная на функционировании» (behaviour-driven development – BDD). 
В сфере автомобильных систем BDD подход мог бы сильно облегчить процесс разработки. 

TODO: обзор глав



Работа организована следующим образом. В главе \ref{cReview} представлен 
обзор проблемы создания вечного двигателя. Глава \ref{cDesign} содержит 
описание предлагаемого подхода к его построению. Вопросы его практической 
реализации рассмотрены в главе \ref{cImplementation}. Результаты 
экспериментального исследования его эффекивности приведены в главе 
\ref{cExperiments}. В приложении \ref{cHints} приведены правила оформления 
различных элементов работы и рекомендации по использованию инструментария 
\LaTeX.


%------------Постановка задачи и обзор литературы -------------------
\chapter{Обзор литературы и постановка задачи }
\label{cReview}
%Рекомендуемый объем главы "--- 10--15 стр. 
%Название главы должно отражать ее содержание, например ``Проблема вечного 
%двигателя''.

%---------------------------ГЛАВА 1.1 ЦЕЛЬ И ЗАДАЧИ
\section{ Цель и задачи} Целью выпускной квалификационной работы является разработка domain specific языка для функционального тестирования автомобильных систем, который облегчит взаимодействие между тестировщиком, заказчиком, менеджером, аналитиками, разработчиками и предоставит функционал, необходимый для симуляции работы автомобильных сетей. Такой язык позволит достичь большего взаимопонимания между менеджерами, аналитиками и инженерами, что в свою очередь значительно упростит разработку ПО и повысит качество разрабатываемого продукта. 
Для достижения поставленной цели следует выполнить ряд задач:
\begin{itemize}
\itemИсследовать предметную область
\itemВыделить аналоги и сравнить их
\itemРазработать язык
\itemРеализовать язык
\itemПротестировать язык
\end{itemize}


%---------------------------ГЛАВА 1.2.	Обзор литературы
\section{ Обзор литературы}
Одно и то же оборудование, разрабатываемое для разных автомобильных компаний с различной внутренней архитертурой программного обеспечения при тестироввании ПО может рассматриваться в качестве «черного ящика». В этом случае тестируется функциональное поведение объекта. Под этой стратегией понимается создание тестов для тестового набора, основанных на технических требованиях и их спецификациях. 

В марте 2006 года Dan North предложил BDD методологию (behaviour-driven development), основанную на agile методологиях. BDD является своего рода расширением техники разработки программного обеспечения через тестирование (test-driven development, TTD). Идея BDD подхода была в том, что в процессе написания требования для разрабатываемого ПО аналитики должны описать тестовые сценарии таким образом, чтобы их смог понять и разработчик, и тестировщик. При этом тестовые сценарии состоят из набора заранее обговоренных предложений. 
В своей статье Dan North описал следующие BDD идеи:

\begin{itemize}
\itemНазвание тестового метода должно быть предложением. В этом случае хорошо разработанная документация будет понятна и бизнес пользователям и инженерам. 
\itemПростой шаблон делает тестовые методы более определенными. 
\itemВыразительное название очень помогает, когда тест обрушился.
\itemСлово «поведение» более полезное, чем «тест».
\itemМетодология BDD предоставляет «общий язык» для анализа. 
\itemПриемочные критерии должны быть выполняемыми.
\end{itemize}

Почти в то же время Эрик Эванс опубликовал книгу «Проблемно-ориентированное проектирование», в которой описал набор принципов и схем, направленных на создание оптимальных систем объектов. Его идея заключается в том, что для бизнеса удобно смоделировать систему, в которой будет определен единый язык (Domain specific language), основанный на бизнес области, такой, что бизнес словарь смогут использовать как менеджеры так и инженеры.  

Совместно Эрик Эванс и Dan North разработали шаблон для выявления приемочных критериев теста. Они разработали структуры тестовых сценариев, в которых каждый шаг определялся ключевым словом
\begin{itemize}
\item	Given – дано начальное условие
\item	When – происходит событие
\item	Then – проверка, что получены некоторые результаты
\end{itemize}

На основе вышеперечисленных принципов BDD был создан язык Gherkin – человеко-читаемый язык, используемый для описания поведения системы.

С точки зрения автомобильной индустрии, в которых функциональное тестирование ПО подразумевает достаточно нетривиальную задачу данный подход сильно облегчает взаимодействие между всеми бизнес участниками. Однако не существует инструмента облегчающего разработку документации, а как следствия взаимопонимания между менеджерами и инженерами и, в то же время, учитывающего особенности данной сферы. 

Возможность использовать единую всеми участниками модель предметной области позволяет значительно ускорить процесс проектирования ПО. Предметно-ориентированое программирование (Domain-driven design, DDD) основано на трех главных определениях:

\begin{itemize}
\item	Область (англ. domain, домен) — предметная область, к которой применяется разрабатываемое программное обеспечение.

\item	Модель (англ. model) — описывает отдельные аспекты области и может быть использована для решения проблемы.

\item	Язык описания — используется для единого стиля описания домена и модели.
\end{itemize}

Использование концепции моделирования системы с использованием единого языка, основанного на бизнес области таким образом, что словарь используется в разработке ПО может решить проблему взаимодействия участников бизнес процесса.

В 2003 году была создана Автомобильная Открытая Системная Архитектура (AUTOSAR, Automotive Open System Architecture). Это открытая архитектура, которая стандартизирует архитектуры ПО для автомобильных ECU и жизненный цикл разработки.  Сегодня в Autosar входят более 150 компаний, и в рамках этого партнерства разрабатывается архитектура ECU, базовое программное обеспечение, методология и стандартизованные интерфейсы для прикладного программного обеспечения.

Учитывая, что все системы стандартизированы, одну и ту же систему (например, лидары для автомобилей марок Diamler и Audi) можно протестировать использую одни и те же инструменты. Однако, среди современных средств для тестирования программных систем нет специализированных под специфические нужды автомобильной промышленности, и при этом позволяющих разрабатывать спецификации на человеко-читаемом языке для реализации BDD подхода.

С расширением областей применения вычислительной техники возникла необходимость в новом — проблемно-ориентированном языке (domain-specific language, DSL), позволяющем в определенной области использовать специфичные обозначения и термины. Такие языки обеспечивают пользователям возможность коротко и четко сформулировать задачу и получить результаты в необходимой для них форме. 


Хорошо разработанный DSL язык должен быть основан на следующих принципах (Debasish, G. 2011 DSLs in Action, Manning Publications):

•	Язык зеркально отображает артефакты предметной области.

•	Язык должен использовать общий словарь предметной области. Словарь становится катализатором для лучшей связи между разработчиками и бизнес-пользователями.

•	Имплементация языка должна быть абстракцией. В язык не должно быть точных фрагментов имплементации языка. 

Использование проблемно-ориентированный языка позволит решить проблему разработки тестовой документации понятной всем участникам бизнес процесса с учетом специфики автомобильной промышленности.


%----------------------------------------ГЛАВА 1.3.	Анализ существующих инструментов для тестирования
\section{Анализ существующих инструментов для тестирования}
%Описание реального объекта исследования, используемых методов исследования,
%техническое и организационное  содержание работ.
%----------------------------------------------------1.3.1.	Выделение критериев сравнения
\subsection{Выделение критериев сравнения}
Требования к разрабатываемой системе
\begin{itemize}
\itemАрхитектура тестов, разрабатываемых с помощью языка, должна быть событийно-управляемая (Event based).  
\itemЯзык должен быть проблемно-ориентированным
\itemЯзык должен позволять использовать BDD подход.
\end{itemize}

\subsection{Обзор аналогов}

\begin{itemize}
  \item CAPL (Communication Access Programming Language)
  
Компания Vector, разрабатывающая программные инструменты для работы с коммуникационными сетями, основывающихся на шинах CAN, LIN, FlexRay, Ethernet и др., используемыми в автомобильной промышленности создала программный пакет для разработчиков: CANoe. Этот инструмент поддерживает симуляцию работы сетей, предоставляет диагностические инструменты и т.д. Данный пакет используется большинством OEM-производителей и поставщиков автомобильных компонентов. В среде CANoe есть возможность разрабатывать тестовые сценарии на языке CAPL (Communication Access Programming Language). 

CAPL - процедурный язык, на котором выполнение блоков программы управляются событиями. Эти блоки программы упоминаются как событие процедуры.

С помощью CAPL можно описать тесты, полностью покрывающие функциональные требования АС. Однако данный язык является Си подобным, достаточно трудным для понимания менеджерами и аналитиками.


  \item CCDL
  
Еще одним языком для описания тестовых спецификаций в автомобильной сфере является CCDL. Это язык тестовых спецификаций для тестирования, основанном на требованиях. Предоставляет высокоуровневый язык тестирования. CCDL может использоваться для автоматизированного black box тестирования. Однако, спецификации содержат в себе программный код, непонятный для части бизнес участников. 

\item Cucumber

Cucumber – это фреймворк, реализующий подход BDD. В Cucumber для разработки тестов используется Gherkin-нотация. Она определяет набор ключевых слов и структуру теста. Программная реализация шагов отделена от теста, что очень удобно для бизнеса. Однако для создания полной domain specific модели АС необходимо каждый раз заново реализовывать протокол коммуникации с тестовым оборудованием. 
\end{itemize}

\subsection{Результаты}
Из вышеперечисленных инструментов для тестирования ПО видно, что ни один из них не удовлетворяет требованиям. Таким образом существует необходимость в создании domain specific языка для функционального тестирования, который объединит в себе принципы BDD и функционал, необходимый для симуляции работы автомобильных сетей CAN, LIN, Ethernet. Наличие такого языка значительно упростит разработку ПО и повысит качество разрабатываемого продукта. 

%------------------------Уточненные требования к работе  TODO
\section{    Уточненные требования к работе }
Окончательная постановка задачи с явным отсечением лишнего 
(чужого, нереализуемого и т.д.)

%------------------------------------Теоретическая часть. Разработка языка
\chapter{Теоретическая часть}
\label{cDesign}
%Рекомендуемый объем главы --- 10--25 стр.
%Название главы должно отражать ее содержание, например ``Построение вечного двигателя на основе технологий объектно-ориентированного программирования''.
%Глава должна содержать
%структурированное описание использованного метода, подхода, математического аппарата, 
%разработанного алгоритма; обоснование решений, доказательство утверждений, 
%аналитические оценки. Основное содержание теоретической части должны 
%составлять результаты, полученные автором. При необходимости, описание 
%используемых классических методов должно быть приведено в главе 

Разрабатываемый язык описания сценариев тестирования автомобильных систем должен быть проблемно-ориентированным, при этом прост в использовании и изучении, а так же предоставлять возможность разрабатывать сценарии не только инженерами, но и бизнес-аналитиками. 

%Компилируемый или интерпретируемый?
Существует два главных вида языков программирования: компилируемый и интерпретируемый. 
	Компилятор выясняет все, что должна выполнить программая, превращает иснтрукции в машинный код и сохраняет его, чтобы выполнить позже. 
	Интрепретатор проходит всю программу строчку за строчкой и тут же выполняет.
	
Технически любой язык может быть, как компилируемым так и интерпретируемым. Обычно компилируемй язык выбирают, если в программе важна скорость работы. Интерпретируемый же язык более гибкий. 

В случае разработки интерпретатора стадии разработки можно разбить на следующие этапы: 

•	Лексический анализ – разбор исходного кода на токены. Этот этап выполняется лексером.

•	Синтаксический анализ – сбор токенов в абстрактное синтаксическое дерево (AST). Данный этап выполняется синтаксическим анализатором (парсером).

•	Исполенение AST 

Естественные языки и искусственные, вне зависимости от их происхождения, представляют собой совокупность строк, состоящих из символа некоторого алфавита. Предложения или утверждения – это строки, состоящие из символов языка. Какие именно утверждения существуют в языке определяют синтаксические правила. 

Первым шагом в разработке языков зачастую язвляется лексический анализ – процесс аналитического разбора входной последовательности символов на лексемы, с целью получения на выходе идентифицированных последовательностей, называемых токенами. Токен – это малая единица языка. Токен может быть именем переменной или функции, оператором или числом. 

Предполагается, что лексер беред входную строку, содержащую файлы с исходным кодом на разрбатываемом языке и разделяет его на список токенов. Лексер может выполнять такие задачи, как удаление комментариев, определение чисел и т.д.

Синтаксический анализ – это процесс сопоставления линейной последовательности лексем (слов, фраз) языка с его формальной грамматикой. Результатом обычно является синтаксическое дерево. Обычно применяется совместно с лексическим анализом. Синтаксический анализатор— это программа или часть программы, выполняющая синтаксический анализ, то есть распознавание входной информации. При этом входные данные преобразуются к виду, пригодному для дальнейшей обработки. Этот вид обычно представляет собой формальную модель входной информации на языке последующего процесса обработки информации.

Во время парсинга входной текст преобразуется в стуктуру данных, которая отражает синтаксичекскую структуру входной последовательности и подходит для последующей обработки. Как правило синтаксическая структура представляется в виде дерева зависимостей. 

Существуют следующие алгоритмы синтаксического анализа: 

•	Нисходящий (англ. top-down) – это такой такой анализ, в котором продукции грамматики раскрываются, начиная со стартового символа, до получения требуемой последовательности лексем.

•	Восходящий (англ. bottom-up) – это такой такой анализ, в котором продукции восстанавливаются из правых частей, начиная с токенов-лексем и кончая стартовым символом.

Во второй половине 20-го века Джон Брэкус и Ноам Хомски независимо друг от друга создали форму записи, которая в последствии стала методом формального описания синтаксиса языков. 
Форма Бэкуса-Наура (БНФ) – формальная система описания синтаксиса, используемая для описания контекстно-свободных грамматик, в которой одни синтаксические абсстракции последовательно определяются через другие абстракции. Для описания синтаксических структур форма БНФ исползует абстракции.  

Форма БНФ является порождающим устройством для определения языков. С помощью последовательности правил создаются преждложения языка. Создание предложений называется выводом.
Вывод должен начинаться с начального символа start symbol. Сентенциальная форма грамматики - это строка, которая может быть выведена из стартового символа. Предложение (сентенция) грамматики - это сентенциальная форма, состоящая только из терминальных символов. Язык L(G) грамматики - это множество всех ее предложений.  

//TODO: РБНФ

Задача построения языка довольна трудозатратная. Однако существуют программные инструменты, помогающие сделать его меньше и проще. Для этого был разработан следующий инструментарий для создания компиляторов:


•	Генераторы лексических анализаторов (сканеров)

•	Генераторы синтаксических анализаторов (парсеров)

•	Автоматические генераторы кода

Для реализации языка было выбрано «еще одно средство распознавания языков» ANTLR4 (ANother Tool for Language Recognition). Это генератор нисходящих анализаторов для формальных языков. Он преобразует контекстно-свободную грамматику в форму РБНФ в программу на Java, C++, JavaSript, Go. Python и Go. 

ANTLR4 удобен для работы с AST, является свободным программным обеспечением, предоставляет сообщение об ошибках и восставновление после них, а так же предоставляет плагины для Eclipse и IntelliJ IDEA, что позволяет удобно создавать и отлаживать грамматики. 

%-------------------------------------ЛЕКСЕР
\section{    Лексер}
DSL для описания тестовых сценариев автомобильных систем должен иметь следующие характерные инструкции (предложения):

•	Отправить фрейм, сигнал или набор данных по UDS протоколу на тестируемое ПО

•	Получить фрейм, сигнал или набор данных по UDS протоколу от тестируемого ПО

•	Сделать паузу между инструкиями, чтобы тестируемое ПО успело сформировать и отправить необходимый пакет

•	Выполнять шаги определенное количество раз, т.к. многие системы имеют алгоритмы со счетчики, которые можно выполнить определенное количесво раз. Зачастую значения таких счетчиков измеряются сотнями и даже тысячами шагов. При удачной группировке этих шагов количество строк тестового сценария можно сократить в десятки раз, поместив из в цикл.

•	Выполнять определенные действия по событию (триггер).

•	Установить значение отправляемого сигнала

•	Проверить полученное значение сигнала

При этом набор иструкций команды, состоящие из аналитиков, тестировщиков и разработчиков должны определять сами, так как процессе разработки автомобильного ПО могут выявляться свойства, специфичные для того или иного программного продукта. У пользователей должна быть позможность описать сценарии с иcпользованием специфичных терминов (рычаги у рулевой колонки, расстояние у лидара и т.д).
 Предполагается, что пользователи сами определяют ограниченный набор шагов, необходимых для описания тестовых сценариев, а тестировщиик набор шагов для каждой инструкции. 
 
Допустим, пользователи обпределили следующий ограниченный набор команд: «Отправить запрос ‘запрос’», «Получить ответ ‘ответ’». При этом формат запроса и ответа является проектно-специфичным, а значит при описани любого шага должна быть возможность описывать кастомизированные параметры. Добиться этого можно, выделив параметр в отдельную лексему. 

Было принято решение, что синтаксис разрабатываемого языка будет иметь аналогичные с Gherkin ключевые слова, возможность описывать сценарии на языке, привычном пользователю, будь то русский или английский. 
Из вышеуказаного можно определить следующий набор ключевых слов с которых должен начинаться любой шаг сценария:  Send, Set, Check, Receive, Pause, Trigger, When, Repeat.

В свою очередь шаги группируются в тестовые сценарии, которых в тестовой спецификации может быть несколько.

При этом для удобства пользователя все эти лексемы языка должны быть регистронезависимы. 
К сожалению, в ANTLR нет поддержки регистронезависимых токенов, и для токенов приходится использовать следующую запись с использованием фрагментных токенов, которые используются для построения реальных токенов: 

fragment S: [sS];

%---------------------------------ПАРСЕР
\section{    Парсер}

Для описания синтаксической структуры языка нужно определить порядок записи:

•	Предложений в тексте;

•	Фраз в предложении;

•	Лексем и фраз в более общих фразах.

Для разрабатываемого языка необходимы такие синтаксические правила как текст инструкции и кастомизированный параметр. При этом текст может содержать пробелы, любые символы английского и русского языков, а так же любые другие символы, кроме символов, обозначающих начало и конец кастомизированного параметра, а так же служебный символ «@», обозначающий начало ключевого слова. 


Синтаксические правила одного шага можно описать следующим образом:

•	Шаг должен начинаться с ключевого символа, определяемого служебным символом “@”

•	Шаг не может начинаться с пользовательского параметра

•	Шаг может начинаться с любого символа

•	Шаг может иметь сколь угодно много параметров


TODO: описать синтаксические правила шагов и сценария в целом

\section{    Использование грамматики}

Для использования разработанного парсера ANTLR4 представляет возможность сгенерировать два паттерна проектирования: Visitor (посеттель) и Listener(слушатель). Каждый из них предполагает анализ определенного подмножества узлов дерева разбора. Узлы дерева разбора, не являющиеся листьями, соответствуют каким-либо синтаксическим правилам грамматики. При анализе узлов дерева разбора нужно обращаться к дочерним узлам, соответствующим фрагментам исходного правила. Причем обращаться можно как к отдельным узлам, так и к группам узлов. Следовательно важным условием создания хорошей грамматики является возможность интуитивно простой доступ к любой части правила. ANTLR4 предоставляет такие сущности как альтернативные и элементарные метки. Альтернативные метки позволяют разбить сложное правило на альтернативные фразы и обрабатывать каждую фразу отдельно.  
В нашем случае правило инструкции можно разбить на следующие альтервативные метки:  
%TEST LISTING 
\lstinputlisting[caption= альтервативные метки синтаксического правила instruction,language=java,  firstline=11, 	 lastline=16 ]{res/BddParser.g4}
%END TEST LISTING 
%instruction
%    : Send  text     #send
%    | Recieve text   #recieve
%    | Set text       #set
%    | Check text     #check
%    | Pause time     #pause

Элементными метками помечаются отдельные нетерминалы или последовательности терминалов. Они предоставляют доступ к содержимому контекста правила в виде поля с заданным именем. Таким образом, вместо вычисления (извлечения) отдельного элемента содержимого некоторого контекста достаточно просто обратиться к такой элементной метке.


%--------------------------------------Обработчик ошибок
\section{    Обработчик ошибок}

В случае, если исходный текст не соотвествует синтаксическим правилам языка, небоходимо корректно реагировать на некорректную цепочу лексем. В этом случае можно завершить синтаксический анализ и вывести сообщение об ошибке, либо попробовать за одну попутку синтаксического анализа найти как можно больше ошибок. 

TODO: описать

\chapter{Реализационная часть}
\label{cImplementation}
Рекомендуемый объем главы --- 10-30 стр.
Название главы должно отражать ее содержание, например ``Архитектура вечного двигателя''.
В главе должно быть описание этапов разработки технического решения задачи. Следующий пример
приведен для работ, связанных  с проектированием и реализацией 
программного продукта.
\section{Архитектура системы}
Псевдокоды или блок-схемы основных алгоритмов, основные структуры данных  и др.
\section{Интерфейс системы}
\label{sSpec}
Интерфейс пользователя, модульная структура, API
\section{Особенности реализации}
Использованные инструментальные средства, приемы программирования, 
технические решения, связанные с ограничениями аппаратных или программных 
средств.  



\chapter{Экспериментальная часть }
\label{cExperiments}
%Рекомендуемый объем главы --- 5--20 стр.
%Название главы должно отражать ее содержание, например ``Оценка эффективности вечного двигателя''.



\section{Тестирование и испытание метода или программы}
%Проверка адекватности модели, сравнение с существующими аналогами, выбор 
%представительного множества тестов, анализ результатов испытаний.

Для тестирования реализованного языка были разработа Unit тесты. Модульное тестирование, оно же юнит-тестирование, позволяет проверить корректность отдельных модулей исходного кода программы. 

Ниже представлена спецификация для разработанного синтаксического анализатора и результаты выполнения тестов



% Please add the following required packages to your document preamble:
% \usepackage{booktabs}
% \usepackage{graphicx}
%\begin{table}[]
%\resizebox{\textwidth}{!}{%
%\begin{tabular}{@{}lllll@{}}
%\begin{tabular}[c]{@{}l@{}}Входной\\ текст\end{tabular}                       & \begin{tabular}[c]{@{}l@{}}Ожидаемое\\ поведение\end{tabular} & Статус    &  &  \\
%@Pause [erf] ms                                                               & line 1:8 mismatched input 'erf' expecting INTEGER             & выполнено &  &  \\
%@Pause [] ms                                                                  & line 1:8 missing INTEGER at ']'                               & выполнено &  &  \\
%\begin{tabular}[c]{@{}l@{}}@Pause [2] ms\\ @Pause [] ms\end{tabular}          & line 2:8 missing INTEGER at ']'                               & выполнено &  &  \\
%\begin{tabular}[c]{@{}l@{}}@Pause [2] ms\\ @Send\end{tabular}                 & line 2:6 missing TEXT at '<EOF>'                              & выполнено &  &  \\
%\begin{tabular}[c]{@{}l@{}}@Pause [2] ms \\ @Send  @Pause [2] ms\end{tabular} & line 2:6 mismatched input '@Pause' expecting TEXT             & выполнено &  & 
%\end{tabular}%
%}
%\end{table}

\lstinputlisting[caption=входные данные для теста testTwoInstructionsInTheSameLine, language=java,  firstline=2,  lastline=8 ]{res/testTwoInstructionsInTheSameLine.txt}

\lstinputlisting[caption=входные данные для теста testSetEmptyInstruction, language=java,  firstline=11,  lastline=19 ]{res/testTwoInstructionsInTheSameLine.txt}


\section{Примеры применения метода или программы}

\Chapter{Заключение }
Рекомендуемый объем --- 2--4 стр.
Содержит изложение итогов квалификационной работы в сопоставлении с общей 
целью и поставленными задачами. Формулировка суждения автора о научной 
новизне и практической ценности ВКР. Предложения по внедрению результатов, 
перспективы продолжения работы 



\bibliographystyle{gost71s}
%\bibliography{bibliography}                              


\end{document}