\documentclass[twoside]{report}
\usepackage[cp1251]{inputenc}
\usepackage[english,russian]{babel}
\usepackage[T2A]{fontenc}
\usepackage{spbstuthesis}
\usepackage{graphicx}
\usepackage{multirow}
\usepackage{amsmath}
\usepackage{subfigure}
\usepackage{appendix}
\usepackage{xcolor}
\usepackage{listings} 

\usepackage{amsfonts}

\bachelor{Разработка и реализация языка описания сценариев тестирования автомобильных систем}{09.03.01 <<Информатика и вычислительная техника>>}{09.03.01\_06 <<Распределенные информационные системы>>}{43504/6}{А. А. Спасеева}{д.т.н., проф.}{ А. В. Самочадин}



\Abstract{Выпускная квалификационная работа посвящена разработке языка описания сценариев тестирования автомобильных систем. Проводится сравнительный анализ схожих по тематике инструментов.

Так же описываются принципы разработки языков и технических инструментов, выбранных для разработки.

Результат работы -- язык описания сценариев тестирования автомобильных систем, являющийся потенциально пригодным для внедрения на производстве.
%для бакалаврских, дипломных и магистерских работ

Ключевые слова: Предметно-ориентированный язык, функциональное тестирование, автомобильные системы.

}{Final year graduation diploma dedicated to the development of the language designed for describing various automobile system testing scenarios. The comparable analysis of systems that share similar instruments is conducted.

Furthermore, this paper aims to describe the development of the programming languages as well as technical instruments used by them.

The final result of this work is a fully functional language used for describing automobile testing scenarios. Also, this language could potentially be integrated into the corporate environment.

Keywords: domain specific language, functional testing, automobile systems.
}

\begin{document}
 
\sloppy
\maketitle
\task{A. A. Спасеевой}{
%для бакалаврских, дипломных и магистерских работ
\item Срок сдачи работы.
\item Исходные данные к проекту (работе).
\item Содержание расчетно-пояснительной записки (перечень подлежащих 
разработке вопросов).
\item Перечень графического материала с точным указанием обязательных 
чертежей.
\item Консультанты по проекту (с указанием относящегося к ним разделов 
проекта, работы).
}
%для бакалаврских, дипломных и магистерских работ
\makeabstract
\tableofcontents



%для бакалаврских, дипломных и магистерских работ
\Chapter{Список обозначений}
\begin{tabular}{ll}
UML& Унифицированный язык моделирования\\
ECU&Electronic Control Unit\\
BDD& Behaviour-driven development\\
ПО & Программное обеспечение\\
TTD&Test-driven development\\
DSL& Domain-specific language\\
AUTOSAR&Automotive Open System Architecture\\
БНФ&Форма Бэкуса-Наура\\
РБНФ&Расширенная форма Бэкуса-Наура\\
AST& Abstract syntax tree\\
АС&Автомобильные системы
\end{tabular}

%------------------------ВВЕДЕНИЕ-----------------------------
\Chapter{Введение}
С развитием автомобильной промышленности тестирование автомобильных систем стало неотъемлемой частью жизненного цикла разработки программного и аппаратного обеспечения. Современные автомобили включают множество встроенных систем для повышения уровня безопасности и комфорта водителей и пассажиров путем обеспечения функций, таких как адаптивный круиз-контроль, контроль давления в шине и др. 

Современные автомобили имеют несколько блоков управления (electronic control unit, ECU), связанных между собой внутримашинной сетью. Эти блоки взаимодейсвуют между собой через стандартные шинные архитектуры CAN, FlexRay, LIN и Ethernet. С развитием техники количество ECU в автомобильных системах стремительно растет, что приводит к созданию сложных стуктур сетей. К основным особенностям автомобильного программного обеспечения можно отнести:
\begin{itemize}
\item	надежность: в сложной сети ECU в течение всего срока эксплуатации автомобиля автомобильные программные системы должны работать исключительно надежно;
\itemфункциональная безопасность: такие функции, как антиблокировочная тормозная система, требуют безотказной работы, что определяет высокие требования к процессам разработки программного обеспечения и к самим программам;
\itemработа в режиме реального времени: быстрая реакция (от микросекунд до миллисекунд) на внешние события требует оптимизированных операционных систем и особой программной архитектуры;
\itemминимальное потребление ресурсов: любое дополнение вычислительных ресурсов или памяти увеличивает стоимость продуктов, что при миллионных тиражах выливается в немалые деньги;
\itemнадежная архитектура: автомобильное программное обеспечение должно выдерживать искажение сигналов и поддерживать электромагнитную совместимость;
\end{itemize}
Функциональные проверки безопасности автомобильных систем на программном уровне включают: 
\begin{itemize}
\itemФункциональное тестирование, целью которого является предоставление гарантий, что ПО удовлетворяет требованиям высокого и низкого уровней.
\itemАнализ времени выполнения худшего сценария, для того, чтобы гарантировать, что критические функции ПО выполняются достаточно быстро (такие как срабатывание подушек безопасности).
\itemСтруктурный анализ покрытия.
\end{itemize}


Что касается тестирования автомобильных систем, необходимо хорошо понимать, как устроен автомобиль в целом и его составляющие по отдельности. Однако представления о системе у инженеров и менеджеров зачастую очень сильно расходятся. Взаимодействие участников бизнес процессса, а именно заказчика, бизнес-аналитика, менеджера, разработчика и тестировщика является неотъемлемой частью гибкой методологии разработки ПО (Agile software development). 

В данной работе рассматривается разработка языка для функционального тестирования ПО автомобильных систем таким образом, чтобы тестовая документация была понятна всем участникам бизнес цикла. 
Практика «разработка через поведение» (behaviour-driven development, BDD) была создана для достижения взаимопонимания между всеми участниками процесса. В сфере автомобильных систем BDD подход сильно облегчать процесс разработки. 


Данная работа организована следующим образом. В главе \ref{cReview} представлен 
обзор проблемы создания языка для описания тестовых сценариев тестирования автомобильных систем и обзор аналогов. Глава \ref{cDesign} содержит 
описание предлагаемого подхода к непосредственному построению языка. Вопросы его практической 
реализации рассмотрены в главе \ref{cImplementation}. Результаты 
экспериментального исследования его эффекивности приведены в главе 
\ref{cExperiments}. 

%------------Постановка задачи и обзор литературы -------------------
\chapter{Обзор литературы и постановка задачи }
\label{cReview}
%Рекомендуемый объем главы "--- 10--15 стр. 
%Название главы должно отражать ее содержание, например ``Проблема вечного 
%двигателя''.

%---------------------------ГЛАВА 1.1 ЦЕЛЬ И ЗАДАЧИ
\section{Цель и задачи} Целью выпускной квалификационной работы является разработка проблемно-ориентированного языка для функционального тестирования автомобильных систем, который облегчит взаимодействие между тестировщиком, заказчиком, менеджером, аналитиками, разработчиками и предоставит функционал, необходимый для симуляции работы автомобильных сетей. Такой язык позволит достичь большего взаимопонимания между менеджерами, аналитиками и инженерами, что в свою очередь значительно упростит разработку ПО и повысит качество разрабатываемого продукта. 
Для достижения поставленной цели следует выполнить ряд задач:
\begin{itemize}
\itemИсследовать предметную область
\itemВыделить аналоги и сравнить их
\itemРазработать язык
\itemРеализовать язык
\itemПротестировать язык
\end{itemize}


%---------------------------ГЛАВА 1.2.	Обзор литературы
\section{Обзор литературы}


Современный автомобиль обладает огромным количеством компьютеров, которые общаются между собой на разных скоростях и типах коммуникаций, так как призваны выполнять разные задачи. С очень быстрым внедрением электронных встроенных систем в транспортных средствах потребность отследить и управлять различными параметрами транспортного средства стала необходимостью. Таким образом были разработаны диагностические системы, чтобы клиенты (проектировщики, тестировщики и механики) могли обнаружить ошибки в транспортном средстве, с помощью соединения их диагностического оборудования c электронным блоком управления в транспортном средстве.
% Компьютерная диагностика автомобиля  -- это диагностика различных систем автомобиля, производящаяся его блоком управления. 

Бортовые системы современного автомобиля оборудованы электронным блоком управления с функцией самодиагностики, анализирующим основные системы автомобиля и оповещающим водителя об их неисправности. 
Для компьютерной диагностики электронный блок управления на физческом уровне подключается к стенду через специализированные диагностические интерфейсы, оснащенному датчиками, посредством которых данные о работе систем передаются для дальнейшего анализа на компьютер. На этом этапе удалятся собранная бортовой системой база данных, а также активируется управляющее устройство для сбора информации. 

Одной из областей в автомобильном тестировании является диагностика транспортных стредств, описанная в серии стандартов UDS ISO 14229.
Unified Diagnostic Service (UDS) - автомобильный протокол, который позволяет диагностическим системам общаться с ECU, чтобы диагностировать ошибки и при необходимости повторно программировать ECU. Потребность в стандарте возникла так как производители транстпортных средств собирают автомобильные компоненты у разных поставщиков. До возникновения UDS ISO 14229 поставщики должны были заниматься проблемами совместимости между различными диагностическими протоколами, сейчас же все ECU разрабатываются, придерживаясь данного стандарта. Архитектура UDS протокола разработана, основываясь на сетевой модели OSI (Open System Interconnection) и определяет пятый (сетевой уровень) и седьмой (прикладной уровень) модели. 

Стек протокола UDS предлагает четыре важных категории сервисов:
 \begin{itemize}
 \itemЗагрузка данных в ECU для разрешения программных ошибок или добавления вновь разработанных программных модулей;
 \itemУдаленная активация рутин. Диагностика транспортного средства может потребовать тестирования некорректного компонента в определенном  диапазоне значений.  Более того во время тестирования некоторые некоторые шаги могут выполняться в течении определенного времени. Для такого рода активностей используется Remote Routine Service, описанный в ISO 14229. 
 \itemВозможность передачи данных позволяет клиентам читать или записывать данные в ECU. Данные могут быть считанны или записаны в ячейки памяти, имеющие 16-битный адресс. Информация может быть статичной, как серийный номер устройства, и динамической, как скорость мотора или статус сенсоров. Допустимые значения данных и их длина могут варьироваться в зависимости от адреса ячейки памяти.
 \itemДиагностика ошибок. Это один из самых важных сервисов UDS протокола. Когда в ECU возникает ошибка, DTC (Diagnostic trouble code), соответствующий возникшей ошибке  сохраняется в определенной области памяти, называемой FCM (Faut Code Memory). Каждая ошибка имеет одно или несколько условий возникновения, обычно описываемые в требованиях.
 \end{itemize}
 
 
Одно и то же оборудование, разрабатываемое для разных автомобильных компаний с различной внутренней архитертурой программного обеспечения при тестироввании ПО может рассматриваться в качестве «черного ящика». Данное понятие предложил У.Р. Эшби в своей книге `` Введение в кибернетику''. Под черным ящиком подразумевается объект исследования, внутреннее устройство которого неизвестно. В электро-вычислительных системах оно помогает изучать поведение систем, абстрагируясь от их внутреннего устройства. Такое тестирование называется поведенческим. В этом случае проверяется функциональное поведение объекта с точки зрения внешнего мира. Под этой стратегией понимается создание тестов для тестового набора, основанных на технических требованиях и их спецификациях. Фактически, при поведенческом тестировании известно какой результат должен быть при определенном наборе данных, которые подаются на вход. Проанализировав требования и спецификации тестировщик может легко определить набор тестовых сценариев для проверки различной функциональности тестируемой системы. Принимая тестируемую систему в качестве черного ящика ее можно исследовать, манипулируя входными данными и данными, полученными на выходе. Чтобы лучше понять, как исследуется оведение ``черного ящика'', предположим что имеется некоторая система управления, внутреннее устройство которой неизвестно для пользователя. Эта система управления имеет входы $X(x_1, x_2, ..., x_n)$ и выходы $Y(y_1, y_2, ..., y_n)$. Способ исследования поведения данной системы заключается в том, что выходы системы зависят от входов системы и времени $t_k, k \in \mathbb{Z}$. При этом величины времени выбираются произвольно (рис. \ref{fblackbox}) .
%\\
%\\
%$y_1(t), y_2(t), ..., y_n(t)$ 
%\\
%\\

\begin{Figure}{Исследование поведения ``черного ящика''}{fblackbox}
{\includegraphics[width=\linewidth]{res/blackBox}}
\label{fig:image}
\end{Figure}
 

В марте 2006 года Dan North предложил BDD методологию (behaviour-driven development), основанную на agile  методологиях. BDD является своего рода расширением техники разработки программного обеспечения через тестирование (test-driven development, TDD). Идея BDD подхода была в том, что в процессе написания требования для разрабатываемого ПО аналитики должны описать тестовые сценарии таким образом, чтобы их смог понять и разработчик, и тестировщик, и заказчик. При этом тестовые сценарии состоят из набора заранее обговоренных предложений. 
В своей статье Dan North описал следующие BDD идеи:

\begin{itemize}
\itemНазвание тестового метода должно быть предложением. В этом случае хорошо разработанная документация будет понятна и бизнес пользователям и инженерам. 
\itemПростой шаблон делает тестовые методы более определенными. 
\itemВыразительное название очень помогает, когда тест обрушился.
\itemСлово «поведение» более полезное, чем «тест».
\itemМетодология BDD предоставляет «общий язык» для анализа. 
\itemПриемочные критерии должны быть выполняемыми.
\end{itemize}

Почти в то же время Эрик Эванс опубликовал книгу «Проблемно-ориентированное проектирование», в которой описал набор принципов и схем, направленных на создание оптимальных систем объектов. Его идея заключается в том, что для бизнеса удобно смоделировать систему, в которой будет определен единый язык (Domain specific language), основанный на бизнес области, такой, что бизнес словарь смогут использовать как менеджеры так и инженеры.  

Совместно Эрик Эванс и Dan North разработали шаблон для выявления приемочных критериев теста. Они разработали структуры тестовых сценариев, в которых каждый шаг определялся ключевым словом
\begin{itemize}
\item	Given – дано начальное условие
\item	When – происходит событие
\item	Then – проверка, что получены некоторые результаты
\end{itemize}

На основе вышеперечисленных принципов BDD был создан язык Gherkin – человеко-читаемый язык, используемый для описания поведения системы.

С точки зрения автомобильной индустрии, в которых функциональное тестирование ПО подразумевает достаточно нетривиальную задачу данный подход сильно облегчает взаимодействие между всеми бизнес участниками. Однако не существует инструмента облегчающего разработку документации, а как следствия взаимопонимания между менеджерами и инженерами и, в то же время, учитывающего особенности данной сферы. 

Возможность использовать единую всеми участниками модель предметной области позволяет значительно ускорить процесс проектирования ПО. Предметно-ориентированое программирование (Domain-driven design, DDD) основано на трех главных определениях:
\begin{itemize}
\itemОбласть (англ. domain, домен) — предметная область, к которой применяется разрабатываемое программное обеспечение.
\itemМодель (англ. model) — описывает отдельные аспекты области и может быть использована для решения проблемы.
\itemЯзык описания — используется для единого стиля описания домена и модели.
\end{itemize}

Использование концепции моделирования системы с использованием единого языка, основанного на бизнес области таким образом, что словарь используется в разработке ПО может решить проблему взаимодействия участников бизнес процесса.

В 2003 году была создана Автомобильная Открытая Системная Архитектура (AUTOSAR, Automotive Open System Architecture). Это открытая архитектура, которая стандартизирует архитектуры ПО для автомобильных ECU и жизненный цикл разработки.  Сегодня в Autosar входят более 150 компаний, и в рамках этого партнерства разрабатывается архитектура ECU, базовое программное обеспечение, методология и стандартизованные интерфейсы для прикладного программного обеспечения.

Учитывая, что все системы стандартизированы, одну и ту же систему (например, лидары для автомобилей марок Diamler и Audi) можно протестировать использую одни и те же инструменты. Однако, среди современных средств для тестирования программных систем нет специализированных под специфические нужды автомобильной промышленности, и при этом позволяющих разрабатывать спецификации на человеко-читаемом языке для реализации BDD подхода.

С расширением областей применения вычислительной техники возникла необходимость в новом — проблемно-ориентированном языке (domain-specific language, DSL), позволяющем в определенной области использовать специфичные обозначения и термины. Такие языки обеспечивают пользователям возможность коротко и четко сформулировать задачу и получить результаты в необходимой для них форме. 


Хорошо разработанный DSL язык должен быть основан на следующих принципах (Debasish, G. 2011 DSLs in Action, Manning Publications):
\begin{itemize}
\itemЯзык зеркально отображает артефакты предметной области.
\itemЯзык должен использовать общий словарь предметной области. Словарь становится катализатором для лучшей связи между разработчиками и бизнес-пользователями.
\itemИмплементация языка должна быть абстракцией. В язык не должно быть точных фрагментов имплементации языка. 
\end{itemize}

Использование проблемно-ориентированный языка позволит решить проблему разработки тестовой документации понятной всем участникам бизнес процесса с учетом специфики автомобильной промышленности.


%----------------------------------------ГЛАВА 1.3.	Анализ существующих инструментов для тестирования
\section{Анализ существующих инструментов для тестирования}
%Описание реального объекта исследования, используемых методов исследования,
%техническое и организационное  содержание работ.
%----------------------------------------------------1.3.1.	Выделение критериев сравнения
\subsection{Выделение критериев сравнения}
Требования к разрабатываемой системе
\begin{itemize}
\itemАрхитектура тестов, разрабатываемых с помощью языка, должна быть событийно-управляемая (Event based).  
\itemЯзык должен быть проблемно-ориентированным
\itemЯзык должен позволять использовать BDD подход.
\end{itemize}

\subsection{Обзор аналогов}

\begin{itemize}
  \item CAPL (Communication Access Programming Language)
  
Компания Vector, разрабатывающая программные инструменты для работы с коммуникационными сетями, основывающихся на шинах CAN, LIN, FlexRay, Ethernet и др., используемыми в автомобильной промышленности создала программный пакет для разработчиков: CANoe. Этот инструмент поддерживает симуляцию работы сетей, предоставляет диагностические инструменты и т.д. Данный пакет используется большинством OEM-производителей и поставщиков автомобильных компонентов. В среде CANoe есть возможность разрабатывать тестовые сценарии на языке CAPL (Communication Access Programming Language). 

CAPL - процедурный язык, на котором выполнение блоков программы управляются событиями. Эти блоки программы упоминаются как событие процедуры.

С помощью CAPL можно описать тесты, полностью покрывающие функциональные требования АС. Однако данный язык является Си подобным, достаточно трудным для понимания менеджерами и аналитиками.


\begin{Figure}[h]{Тестовая спецификация CAPL}{fcapl}
{\includegraphics[width=\linewidth]{res/Capl}}
\label{fig:image}
\end{Figure}


\item CCDL
 
Еще одним языком для описания тестовых спецификаций в автомобильной сфере является CCDL. Это язык тестовых спецификаций для тестирования, основанном на требованиях. Предоставляет высокоуровневый язык тестирования. CCDL может использоваться для автоматизированного black box тестирования. Однако, спецификации содержат в себе программный код, непонятный для части бизнес участников (рис. \ref{fccdl}). 

 \begin{Figure}[h]{Тестовый сценарий на языке CCDL}{fccdl}
{\includegraphics[width=\linewidth]{res/CAPL-EX}}
\label{fig:image}
\end{Figure}

\item Cucumber

\begin{Figure}[h]{Тестовая спецификация Cucumber}{fcucumber1}
{\includegraphics[width=\linewidth]{res/CUCUMBER-EX-1}}
\label{fig:image}
\end{Figure}

Cucumber – это фреймворк, реализующий подход BDD. В Cucumber для разработки тестов используется Gherkin-нотация. Она определяет набор ключевых слов и структуру теста. Пример тестого сценария, написаного с помощью Cucumber приведена на рис. \ref{fcucumber1} Программная реализация шагов отделена от теста (рис. \ref{fcucumber2}), что очень удобно для бизнеса. Однако для создания полной domain specific модели АС необходимо каждый раз заново реализовывать протокол коммуникации с тестовым оборудованием. 


\begin{Figure}[h!]{Реализация шага Cucumber}{fcucumber2}
{\includegraphics[width=\linewidth]{res/CUCUMBER-EX-2}}
\label{fig:image}
\end{Figure}


\end{itemize}

\subsection{Результаты}
Из вышеперечисленных инструментов для тестирования ПО видно, что ни один из них не удовлетворяет требованиям. Таким образом существует необходимость в создании domain specific языка для функционального тестирования, который объединит в себе принципы BDD и функционал, необходимый для симуляции работы автомобильных сетей CAN, LIN, Ethernet. Наличие такого языка значительно упростит разработку ПО и повысит качество разрабатываемого продукта. 

%------------------------Уточненные требования к работе  TODO
\section{Уточненные требования к работе }
Окончательная постановка задачи с явным отсечением лишнего 
(чужого, нереализуемого и т.д.)

%------------------------------------Теоретическая часть. Разработка языка
\chapter{Теоретическая часть}
\label{cDesign}
%Рекомендуемый объем главы --- 10--25 стр.
%Название главы должно отражать ее содержание, например ``Построение вечного двигателя на основе технологий объектно-ориентированного программирования''.
%Глава должна содержать
%структурированное описание использованного метода, подхода, математического аппарата, 
%разработанного алгоритма; обоснование решений, доказательство утверждений, 
%аналитические оценки. Основное содержание теоретической части должны 
%составлять результаты, полученные автором. При необходимости, описание 
%используемых классических методов должно быть приведено в главе 

Разрабатываемый язык описания сценариев тестирования автомобильных систем должен быть проблемно-ориентированным, при этом прост в использовании и изучении, а так же предоставлять возможность разрабатывать сценарии не только инженерами, но и бизнес-аналитиками. 

%-----------------------------ТЕСТИРОВАНИЕ АВТОМОБИЛЬНЫХ СИСТЕМ
\section{Тестирование автомобильных систем}

Прежде чем начать разрабатывать язык для описания сценариев тестирования автомобильных систем рассмотрим основные стандарты, используемые в транспортной промышленности. 

 
Тестирование автомобильных систем предполагает, что поведение электрических блоков управления транспортного средства должно соответствовать стандарту UDS ISO 14229.
 
Принимая АС в качестве черного ящика их можно исследовать, манипулируя входными данными и  обрабатывая данные, полученные на выходе. В этом случае под данными понимаются кадры автомобильной сети, передающиеся на сетевом уровне модели OSI через стандартные протоколы (CAN, FlexRay, LIN и Ethernet). 

Под тестируемым оборудованием автомобильной системы подразумевается электрический блок управления (ECU), представляющий собой набор плат. Для того, чтобы управлять данным блоком, необходимо наладить канал взаимодействия с ним. Для этого, ввиду отсутвия у платы интерфейсных выходов, используется внешний интерфейсный блок. В качестве интрефейсного блока выступает аппаратное обеспечение, разработанное компанией Vector, называемое VectorBox. Данный блок представляет собой набор интерфейсов для взаимодействия по одному или нескольким протоколам. За реализацию данных протоколов отвечает встроенное программно-аппаратное обеспечение данного устройства. Схема подключения тестируемого оборудования к персональному компьютеру представлена на рис. \ref{fConnectionScheme}.


\begin{Figure}[h!]{Схема подключения тестируемого оборудования к PC}{fConnectionScheme}
{\includegraphics[width=\linewidth]{res/ConnectionScheme}}
\label{fig:image}
\end{Figure}

%\subsection{Алгоритм тестирования}
 
Алгоритм тестирования ECU можно описать следующим образом: 
\begin{enumerate}
\itemиз тестовой инструкции извлекаются данные, необходимые для отправки на ECU;
\itemданные преобразуются в кадры управления VectorBox'ом;
\itemинтерфейсный блок управления (VectorBox) генерирует управляющие сигналы и отправляет их на ECU;
\itemпосле выполнения полученной инструкции ECU генерирует ответ, который отправляется на VectorBox;
\itemпосле получения ответа от ECU VectorBox генерирует кадр и передает через интерфейс пользовательскому компьютеру (PC);
\itemполученный кадр ответа транслирующая система сравнивает с ожидаемым значением, описанным в тестовой спецификации;
\end{enumerate}






Поведенческое тестирование автомобильных систем может быть выполнено следующими способами:
\begin{itemize}
\itemРазделение на классы эквивалентности 

Часто легко заметить, что входные данные имеют схожие характеристики. В этом случае  их можно сгруппировать и подавать на вход только одну единицу данных из каждой группы.  Идея заключается в разделении входных данных на классы эквивалентности таким образом, что каждый член класса обладает схожими характеристиками.  

Данный способ включается в себя два шага: определение класса эквивалентности и генерацию тестовых сценариев. Под определением класса эквивалентности подразумевается разделение входных данных на два класса: корректные и некорректные данные. Например, если действительный диапазон данных от 0 до 100, то в качестве корректных данных могжет быть выбирано значение 49, а в качестве некорректного 106. 

\itemАнализ граничных значений

Тестирование граничные значения данных позволяют достаточно хорошо проверить качество программного обеспечения. Следовательно, если тестовые сценарии разработаны для граничных значений входной области, то эффективность тестирования повышается. Например, если действительный диапазон данных от 0 до 100, то в качестве корректных данных выбираются граничные значения 0 и 100 для кореектных данных, а в качестве некорректных -1 и 101.

\itemТестирование, основанное на требованиях

Данный способ тестирования подразумевает валидацию требований, предоставленных аналитиками и инженерами, которые составляют требования. Например, если в требовании описано, что сеть должна переходить в активный режим при получении любого кадра, то в качестве входных данных формируется любой корректный в данной сети кадр.
\end{itemize}


\subsection {Симуляция работы сетей}

рассказать о шине CAN в промышленной автоматизации, eternet, fleaxray? немного о их пакетах и что нужно для тестирования? 


Основываясь на вышесказанном разрабатываемый язык должен предоставлять пользователям возможность получения передачи данных на сетевом уровне модели ISO по протоколам CAN, FlexRay, LIN и Ethernet.

%-------------------------------СИНТАКСИС ЯЗЫКА
\section{Описание синтаксиса языка }
Существуют три основных метода описания синтаксиса языков программирования: формальные грамматики, формы Бэкуса-Наура и диаграммы Вирта.

Формальной грамматикой называется четверка вида:  G = (VT, VN, P, S), 

где где VN - конечное множество нетерминальных символов грамматики,
VT - множество терминальных символов грамматики 
Р – множество правил вывода грамматики,
S – начальный символ грамматики.

Для записи правил вывода с одинаковыми левыми частями вида a-> b1, a->b2, ..., a->bn   используется сокращенная форма записи a-> b1|b2|...|bn.

%БНФ

Во второй половине 20-го века Джон Брэкус и Ноам Хомски независимо друг от друга создали форму записи, которая в последствии стала методом формального описания синтаксиса языков. 
Форма Бэкуса-Наура (БНФ) – формальная система описания синтаксиса, используемая для описания контекстно-свободных грамматик, в которой одни синтаксические абсстракции последовательно определяются через другие абстракции. Для описания синтаксических структур форма БНФ исползует абстракции.  

Форма БНФ является порождающим устройством для определения языков. С помощью последовательности правил создаются преждложения языка. Создание предложений называется выводом.
Вывод должен начинаться с начального символа start symbol. Сентенциальная форма грамматики - это строка, которая может быть выведена из стартового символа. Предложение (сентенция) грамматики - это сентенциальная форма, состоящая только из терминальных символов. Язык L(G) грамматики - это множество всех ее предложений.  

Метаязык, предложенный Бэкусом и Науром, использует следующие обозначения:
\begin{itemize}
\itemсимвол «::=» отделяет левую часть правила от правой (читается: «определяется как»);
\itemнетерминалы обозначаются произвольной символьной строкой, заключенной в угловые скобки «<» и «>»;
\itemтерминалы - это символы, используемые в описываемом языке;
\itemправило может определять порождение нескольких альтернативных цепочек, отделяемых друг от друга символом вертикальной черты «|» (читается: «или»).
\end{itemize}


%РБНФ
Из-за некоторых незначительных неудобств в БНФ Никлаус Вирт предложил свой вариант расширенной формы Бэкуса-Наура (РБНФ, расширенная Бэкус — Наурова форма). Эти расширения не увеличивают описательну силу БНФ, а упрощают чтение и использование такой формы.  

Для повышения удобства и компактности описаний, в РБНФ вводятся следующие дополнительные конструкции (метасимволы):
\begin{itemize}
\itemквадратные скобки «[» и «]» означают, что заключенная в них синтаксическая конструкция может отсутствовать;
\itemфигурные скобки «\{» и «\}» означают повторение заключенной в них синтаксической конструкции ноль или более раз;
\itemсочетание фигурных скобок и косой черты «\{/» и «/\}» используется для обозначения повторения один и более раз;
\itemкруглые скобки «(» и «)» используются для ограничения альтернативных конструкций.
\end{itemize}

%Диаграммы Вирта

Синтаксическими графами называются ориентированные графы, на которых представляется информия о правилах форм БНФ и РБНФ. Так же их называют синтаксическими диаграммами или синтаксическими схемами.
При построении диаграмм учитывают следующие правила:
\begin{itemize}
\itemкаждый графический элемент, соответствующий терминалу или нетерминалу, имеет по одному входу и выходу, которые обычно изображаются на противоположных сторонах;
\itemкаждому правилу соответствует своя графическая диаграмма, на которой терминалы и нетерминалы соединяются посредством дуг;
\itemальтернативы в правилах задаются ветвлением дуг, а итерации - их слиянием;
\itemдолжна быть одна входная дуга (располагается обычно слева или сверху), задающая начало правила и помеченная именем определяемого нетерминала, и одна выходная, задающая его конец (обычно располагается справа и снизу);
\itemстрелки на дугах диаграмм обычно не ставятся, а направления связей отслеживаются движением от начальной дуги в соответствии с плавными изгибами промежуточных дуг и ветвлений.
\end{itemize}

%Компилируемый или интерпретируемый?
\section{Общая структура}
Существует два главных вида языков программирования: компилируемый и интерпретируемый. 
	Компилятор выясняет все, что должна выполнить программая, превращает иснтрукции в машинный код и сохраняет его, чтобы выполнить позже. 
	Интрепретатор проходит всю программу строчку за строчкой и тут же выполняет.
	
Технически любой язык может быть, как компилируемым так и интерпретируемым. Обычно компилируемй язык выбирают, если в программе важна скорость работы. Интерпретируемый же язык более гибкий. 

В случае разработки интерпретатора стадии разработки можно разбить на следующие этапы: 

\begin{itemize}
\itemЛексический анализ – разбор исходного кода на токены. Этот этап выполняется лексером.
\itemСинтаксический анализ – сбор токенов в абстрактное синтаксическое дерево (AST). Данный этап выполняется синтаксическим анализатором (парсером).
\itemсемантический анализ;
\itemИсполенение AST 
\end{itemize}



Естественные языки и искусственные, вне зависимости от их происхождения, представляют собой совокупность строк, состоящих из символа некоторого алфавита. Предложения или утверждения – это строки, состоящие из символов языка. Какие именно утверждения существуют в языке определяют синтаксические правила. 

%---------------------------------------ЛЕКСИЧЕСКИЙ АНАЛИЗ
\subsection {Лексичекий анализ}
Первым шагом в разработке языков зачастую язвляется лексический анализ – процесс аналитического разбора входной последовательности символов на лексемы, с целью получения на выходе идентифицированных последовательностей, называемых токенами. Токен – это малая единица языка. Токен может быть именем переменной или функции, оператором или числом. 

Предполагается, что лексер беред входную строку, содержащую файлы с исходным кодом на разрбатываемом языке и разделяет его на список токенов. Лексер может выполнять такие задачи, как удаление комментариев, определение чисел и т.д.

ЛА необязательный этап, но желательный так как:

1) замена идентификаторов, констант, ограничителей и служебных слов лексемами делает программу более удобной для дальнейшей обработки.

2) Лексический анализатор уменьшает длину программы, устраняя из ее исходного представления комментарии и несущественные пробелы.

3) если будет изменена кодировка в исходном представлении программы, то это отразится только на лексическом анализаторе.

В процедурных языках лексемы обычно делятся на классы:  служебные слова и ограничители.


Входные данные ЛА - текст транслируемой программы на входном языке.

Выходные данные ЛА - файл лексем в числовом представлении. %TODO добавить листинг BddLexer.tokens





\subsection {Синтаксический анализ}
%синтаксический анализ
Синтаксический анализ – это процесс сопоставления линейной последовательности лексем (слов, фраз) языка с его формальной грамматикой. Результатом обычно является синтаксическое дерево. Обычно применяется совместно с лексическим анализом. Синтаксический анализатор— это программа или часть программы, выполняющая синтаксический анализ, то есть распознавание входной информации. При этом входные данные преобразуются к виду, пригодному для дальнейшей обработки. Этот вид обычно представляет собой формальную модель входной информации на языке последующего процесса обработки информации.

Во время парсинга входной текст преобразуется в стуктуру данных, которая отражает синтаксичекскую структуру входной последовательности и подходит для последующей обработки. Как правило синтаксическая структура представляется в виде дерева зависимостей. 

Существуют следующие алгоритмы синтаксического анализа: 
\begin{itemize}
\itemНисходящий (англ. top-down) – это такой такой анализ, в котором продукции грамматики раскрываются, начиная со стартового символа, до получения требуемой последовательности лексем.
\itemВосходящий (англ. bottom-up) – это такой такой анализ, в котором продукции восстанавливаются из правых частей, начиная с токенов-лексем и кончая стартовым символом.
\end{itemize}

Нисходящий анализ (метод рекурсивног оспуска) является наиболее эффективным методом синтаксического анализа. В его основе лежит левосторонний разбор строки языка. Исходной сентенциальной формой является начальный символ грамматики, а целевой – заданная строка языка. На каждом шаге разбора правило грамматики применяется к самому левому нетерминалу сентенции. Данный процесс соответствует построению дерева разбора цепочки сверху вниз (от корня к листьям).

%ДЕРЕВЬЯ СИНТАКСИЧЕСКОГО АНАЛИЗА


\subsection {Семантический анализ}
В ходе семантического анализа проверяются отдельные правила записи исходных программ, которые не описываются КС-грамматикой. Эти правила носят контекстно-зависимый характер, их называют семантическими соглашениями или контекстными условиями.

Пользовательские инструкции, используемые в тестовых сценариях должны быть заранее обьявлены пользователями в специальной бибилиотеке. Ключевое слово должно отражать смысл инструкции: Send- для отправки пакета, Recieve - для получания пакета и т.д. 

В теле метода  сооветствующей инструкции должны быть реализованы шаги отправки, получения пакетов и т.д. в зависимости от аннотации. Для того, чтобы определить метод, который должен быть выполнен при вызове заданной текстовой инструкции, а так же приведения типов пользовательских параметров можно использовать рефлексию.

Рефлексия (от лат. reflexio — обращение назад) — это механизм исследования данных о программе во время её выполнения. Рефлексия позволяет исследовать информацию о полях, методах и конструкторах классов. 

Механизм рефлексии позволяет обрабатывать типы, отсутствующие при компиляции, но появившиеся во время выполнения программы. Возможность использования рефлексии реализована в Java с помощью Reflection API.  


% ------------------------------------------------ГЛАВА Реализационная часть
\chapter{Реализационная часть}
\label{cImplementation}
%Рекомендуемый объем главы --- 10-30 стр.
%Название главы должно отражать ее содержание, например ``Архитектура вечного двигателя''.
%В главе должно быть описание этапов разработки технического решения задачи. Следующий пример
%приведен для работ, связанных  с проектированием и реализацией 
%программного продукта.


Задача построения языка довольна трудозатратная. Однако существуют программные инструменты, помогающие сделать его меньше и проще. Для этого был разработан следующий инструментарий для создания компиляторов: генераторы лексических анализаторов (сканеров), генераторы синтаксических анализаторов (парсеров), автоматические генераторы кода.

Для реализации языка было выбрано «еще одно средство распознавания языков» ANTLR4 (ANother Tool for Language Recognition). Это генератор нисходящих анализаторов (парсеров) для формальных языков. Он преобразует контекстно-свободную грамматику в форме РБНФ в программу на Java, C++, JavaSript, Go. Python и Go. 

ANTLR4 удобен для работы с AST, является свободным программным обеспечением, предоставляет сообщение об ошибках и восставновление после них, а так же предоставляет плагины для Eclipse и IntelliJ IDEA, что позволяет удобно создавать и отлаживать грамматики. Интерпретатор реализован на языке java.

%-------------------------------------ЛЕКСЕР
\section{Лексер}
Предметно-ориентированный язык для описания тестовых сценариев автомобильных систем должен  должен позволять описывать следующие виды инструкций, необходимых для описания входных и выходных данных:
\begin{itemize}
\itemОтправить фрейм, сигнал или набор данных по UDS протоколу на тестируемое ПО
\itemПолучить фрейм, сигнал или набор данных по UDS протоколу от тестируемого ПО
\itemСделать паузу между инструкиями, чтобы тестируемое ПО успело сформировать и отправить необходимый пакет
\itemВыполнять шаги определенное количество раз, т.к. многие системы имеют алгоритмы со счетчики, которые можно выполнить определенное количесво раз. Зачастую значения таких счетчиков измеряются сотнями и даже тысячами шагов. При удачной группировке этих шагов количество строк тестового сценария можно сократить в десятки раз, поместив из в цикл.
\itemВыполнять определенные действия по событию (триггер).
\itemУстановить значение отправляемого сигнала
\itemПроверить полученное значение сигнала
\end{itemize}

При этом  команды, состоящие из аналитиков, тестировщиков и разработчиков  должны сами определять набор иструкций , так как в процессе разработки автомобильного ПО могут выявляться свойства, специфичные для того или иного программного продукта. У пользователей должна быть позможность описать сценарии с иcпользованием специфичных терминов (рычаги у рулевой колонки, расстояние у лидара и т.д).
Предполагается, что пользователи сами определяют ограниченный набор шагов, необходимых для описания тестовых сценариев, а тестировщиик набор шагов для каждой инструкции. 
 
Допустим, пользователи определили следующий ограниченный набор команд: «Отправить запрос ‘запрос’», «Получить ответ ‘ответ’». При этом формат запроса и ответа является проектно-специфичным, а значит при описании любого шага должна быть возможность описывать кастомизированные параметры. Добиться этого можно, выделив параметр в отдельную лексему. 

Предположим, что синтаксис разрабатываемого языка будет иметь ключевые слова, по которым можно определить входные и выходные данные, возможность описывать сценарии на языке, привычном пользователю, будь то русский или английский. 

В качестве входов системы рассмотрим пакеты данных, отправляемые тестируемому оборудованию, а так же  установку значений  параметров (частота передачи данных, значения отправляемых сигналов и д.р.). В этом случае входы системы можно разделить на два класса: отправка данных и настройка данных. В таком случае выходами системы будут получаемые с тестируемого оборудования пакеты данных. Данные могут приниматься единожды (UDS пакеты), или же переодически (синхросигналы). Соответственно, представляется логичным разделить их на две большие группы: получение пакетов и данные, которые необходимо проверить в определенный момент времени. В этом случае система управления имеет входы $X(Send_{data}, Set_{data})$ и выходы $Y(Recieve_{data}, Check_{data})$. На рис. \ref{blackBoxKeyWords} в качестве входных и выходных данных ``черного ящика'' представлены ключевые слова, которыми назовем четыре группы вышеописанных данных.  

\begin{Figure}{Тестирование автомобильной системы в качестве ``черного ящика''}{blackBoxKeyWords}
{\includegraphics[width=\linewidth]{res/blackBoxKeyWords}}
\label{fig:image}
\end{Figure} 

Так как автомобильные системы тестируются в режиме реального времени, в тестовых сценариях необходимо явно оперировать временем. Ответ на запрос приходит не моментально, так же как и не моментально изменяются значения сигналов. Зачастую возникает необходимость проверить значение полученного сигнала несколько раз в определенные промежутки времени. В этом случае между  отправкой запроса и получением ответа необходимо установить паузу, в течение которой тестовое оборудование не будет выполнять проверку полученных данных на соотвествие ожидаемым данным, описанные в тестовом сценарии. Для реализации этой возможности введем ключевое слово Pause. После данного ключевого слова должно указываться значение $p_n$ такое, что $t_{n+1}=t_n+p_n$.


 
Из вышеуказаного можно определить следующий набор ключевых слов с которых должен начинаться любой шаг сценария:  Send, Set, Check, Receive, Pause.  Реализация данных лексем представлена в листинге \ref{listKeyWords}. 
При этом для удобства пользователя ключевые слова языка должны быть регистронезависимы. 
К сожалению, в ANTLR нет поддержки регистронезависимых токенов, и для токенов приходится использовать следующую запись с использованием фрагментных токенов, которые используются для построения реальных токенов: 

fragment S: [sS];
 
 \lstinputlisting[caption=Ключевые слова, language=java,  firstline=22,  lastline=36 ]{res/BddLexer.g4}{listKeyWords}
 
 После шага должна идти инструкция, определяемая пользователем языка. Например, если необходимо проверить функцию записи определенных данных в энергонезависимой памяти, нужно реализовать следующий набор шагов тестового сценария: 

\begin{itemize}
\itemВключить тестовое оборудование
\itemС помощью сервиса UDS протокола WriteDataByIdentifier (0x2E) записать корректные данные
\itemС помощью сервиса UDS протокола ReadDataByIdentifier (0x22) проверить, что данные успешно записаны
\itemВыключить тестируемое оборудование
\itemВключить тестируемое оборудование
\itemС помощью сервиса UDS протокола ReadDataByIdentifier (0x22) прочитать записанные данные
\itemВыключить тестируемое оборудование
\end{itemize}

Предположим, что для области памяти с адресом 0xF101 корректными данными являются три байта 0x0001A5. 
В этом случае, в соответствии с принципами BDD набор тестовых инструкций, определяемых пользователем могут выглядеть следующим образом: 

\textbf{Set} ignition on, 
\textbf{Send} request [22 F1 01 00 01 A5],  
\textbf{Recieve} response [62 F1 01], 
\textbf{Set} ignition off, 
\textbf{Set} ignition on, 
\textbf{Send} request [2E F1 01], 
\textbf{Pause} 100 ms, 
\textbf{Recieve} response [6E F1 01 00 01 A5], 
\textbf{Set} ignition off.

Такая запись не очень удобна с точки зрения восприимчивости теста. Поэтому разумно ввести правило, что каждое правило должно начинаться с новой строки. Для обозначения новой строки введем лексему \textbf{NewLine}. Подробнее правила синтаксического анализа будут рассмотрены в разделе \ref{lParser}. Более того, нет обозначения начала тестового сценария. Так же в тестовой спецификации должна быть краткая информация для каждого сценария, чтобы можно было быстро понять зачем нужно данное испытание.  Для этого введем ключевое слово \textbf{TestCase}, обозначающее начало сценария, после которого должна идти краткая информация. 
Шаги группируются в тестовые сценарии, которых в тестовой спецификации может быть несколько.



%---------------------------------ПАРСЕР
\section{Парсер}\label{lParser}

Для описания синтаксической структуры языка нужно определить порядок записи:
\begin{itemize}
\itemПредложений в тексте;
\itemФраз в предложении;
\itemЛексем и фраз в более общих фразах.
\end{itemize}

Для разрабатываемого языка необходимы такие синтаксические правила как текст инструкции и кастомизированный параметр. При этом текст может содержать пробелы, любые символы английского и русского языков, а так же любые другие символы, кроме символов, обозначающих начало и конец кастомизированного параметра, а так же служебный символ «@», обозначающий начало ключевого слова. 

Синтаксические правила одного шага можно описать следующим образом:

\begin{itemize}
\itemШаг должен начинаться с ключевого символа, определяемого служебным символом “@”
\itemШаг не может начинаться с пользовательского параметра
\itemШаг может начинаться с любого символа
\itemШаг может иметь сколь угодно много параметров
\end{itemize}

TODO: описать синтаксические правила шагов и сценария в целом


По описанным  правилам ANTLR генерирует файлы для распознания. 
BddParser.java - это описание класса парсера, то есть синтаксического анализатора, отвечающего грамматике BddParser. 
BddLexer.java -это описание класса лексера, или лексического анализатора, отвечающего грамматике 

BddParser.tokens, BddLexer.tokens — это вспомогательные классы, которые содержат информацию о токенах


BddParserVisitor.java, BddParserListener.java, BddParserBaseListener   — это интерфейсы и классы , содержащие описания методов, которые позволяют выполнять определенный действия при обходе синтаксического дерева


Вопрос: вставлять ли картинки с построенными ANTLR ast? 

  
%-------------------------------Использование грамматики
\section{Использование грамматики}

Для использования разработанного парсера ANTLR4 представляет возможность сгенерировать два паттерна проектирования: Visitor (посеттель) и Listener(слушатель). Каждый из них предполагает анализ определенного подмножества узлов дерева разбора. Узлы дерева разбора, не являющиеся листьями, соответствуют каким-либо синтаксическим правилам грамматики. При анализе узлов дерева разбора нужно обращаться к дочерним узлам, соответствующим фрагментам исходного правила. Причем обращаться можно как к отдельным узлам, так и к группам узлов. Следовательно важным условием создания хорошей грамматики является возможность интуитивно простой доступ к любой части правила. ANTLR4 предоставляет такие сущности как альтернативные и элементарные метки. Альтернативные метки позволяют разбить сложное правило на альтернативные фразы и обрабатывать каждую фразу отдельно.  
В нашем случае правило инструкции можно разбить на следующие альтервативные метки:  
\lstinputlisting[caption= альтервативные метки синтаксического правила instruction,language=java,  firstline=11, 	 lastline=16 ]{res/BddParser.g4}


Элементными метками помечаются отдельные нетерминалы или последовательности терминалов. Они предоставляют доступ к содержимому контекста правила в виде поля с заданным именем. Таким образом, вместо вычисления (извлечения) отдельного элемента содержимого некоторого контекста достаточно просто обратиться к такой элементной метке.

В реализации интерпретатора используется паттерн Listener. При обходе абстрактного синтаксического дерева интерпретатор находит очередную нотированную инструкцию, с помощью рефлексии находит метод, аннотированный соотвествующим ключевым словом и добавляет ее в список необходимых для выполнения. При этом инструкция должна быть заранее определена пользователем в библиотеке инструкций. Во время семантического анализа все параметры пользовательских параметров приводятся к типам, объявленным в параметрах метода. Методы инcтрукций могут принимать параметры следующх типов: boolean, byte, short, integer, long, float, double, String, Enum. 

При завершении обхода AST инструкции поочередно выполняются в том порядке, в котором были заданы в тестовой спецификации. 

\lstinputlisting[caption=Пример реализации пользовательской инструкции с аннотацией Send,language=java]{res/annotatoinExample.txt}

Для реализации функционала симуляции автомобильных сетей используется XL-Driver-Library. XL-Driver-Library -- это универсальный программный интерфейс, позволяющий получить доступ к интерфейсам апаратных средств Vector. Он поддерживает следующие шины: 
\begin{itemize}
\item CAN / CAN FD
\item LIN
\item FlexRay
\item Automotive Ethernet
\item MOST
\item ARINC
\end{itemize}

XL-Driver-Library предоставляет общие и шинно-специфичные методы, которые облегчают управлять интерфейсами шины от Vector. Каналы  и порты управляются общими методами. Шинно-специфичные методы используются, чтобы настроить сетевые узлы и послать или получить сообщения.  XL-Driver-Library позволяет эффективно использовать интерфейсы шины в пользовательских приложениях. Особенно полезно это при реализации специализированных иструментов, которые адаптированы к автоматизированному рабочему месту и его окружению, с целью увеличения производительности. 
По словам производителей данная библиотека может быть использована при создании инструментов тестирования для тестового оборудования автомобильных систем. 

Для разработки XL Driver Library приложений требуется подключить динамческие бибилотеки, которые находятся в открытом доступе на сайте компании Vector. необходимые методы реализованы на языке С, поэтому для доступа к методам через java был реализован класс JNIVxlApi.java c использованием  механизма JNI. 

Java Native Interface (JNI) — стандартный механизм для запуска кода, под управлением виртуальной машины Java (JVM), который написан на языках С/С++ или Ассемблера, и скомпонован в виде динамических библиотек, позволяет не использовать статическое связывание. Это даёт возможность вызова функции С/С++ из программы на Java, и наоборот.

%----------------------Архитектура системы
%\section{Архитектура системы}
%Псевдокоды или блок-схемы основных алгоритмов, основные структуры данных  и др.

Ниже представлена диаграмма классов интерпретатора.



\begin{figure}[h]
\center{\includegraphics[width=\linewidth]{res/ClassDiagram}}
\caption{Диаграмма классов}
\label{fig:image}
\end{figure}


%------------------------Интерфейс системы
%\section{Интерфейс системы}
%\label{sSpec}
%Интерфейс пользователя, модульная структура, API
%\section{Особенности реализации}
%Использованные инструментальные средства, приемы программирования, 
%технические решения, связанные с ограничениями аппаратных или программных 
%средств.  


%--------------------------------------Обработчик ошибок
\section{Обработчик ошибок}
Важной способностью каждого парсера является обработка ошибок.
В случае, если исходный текст не соотвествует синтаксическим правилам языка, небоходимо корректно реагировать на некорректную цепочу лексем. В этом случае можно завершить синтаксический анализ и вывести сообщение об ошибке, либо попробовать за одну попутку синтаксического анализа найти как можно больше ошибок. 

%TODO: описать мой обработчик 

В ANTLR существуют следующие типы ошибок парсинга:
\begin{itemize}
\itemошибка распознавания токена (Lexer no viable alt); единственная существующая лексическая ошибка, обозначающая отсутствие правила для формирования токена из существующей лексемы.

%class # { int i; } — здесь такой лексемой является #.

\itemотсутствующий токен (Missing token); в этом случае ANTLR вставляет в поток токенов отсутствующий токен, помечает, что его не хватает, и продолжает парсинг.

%class T { int f(x) { a = 3 4 5; } } — здесь такой токен это } в конце;

\itemлишний токен (Extraneous token). Генератор помечает, что токен ошибочный и продолжает парсинг дальше.
%class T ; { int i; }

\itemнесовместимая входная цепочка (Mismatched input). При этом включается «режим паники», цепочка входных токенов игнорируется, а парсер ожидает токена из синхронизирущего множества. 

%class T { int f(x) { a = 3 4 5; } }

\itemотсутствующая альтернатива (No viable alternative input). Данная ошибка описывает все остальные возможные ошибки парсинга.

%class T { int ; }

\end{itemize}
Для обработки ошибок используется класс ThrowingErrorListener, наследуемый от BaseErrorListener. BaseErrorListener предоставляет пустую имплементацию интерфейса  ANTLRErrorListener. Реализация каждого метода по умолчанию ничего не делает, но может быть переписана в наследнике по мере необходимости. Для обработки синтаксических ошибок используется метод 	syntaxError, уведомляющий в какой строке и в на какой позиции в строке возникла ошибка и ее причину. 

Ниже представлен пример тестового сценария с синтаксической ошибкой: на 9 строке после ключевого слова не указана текстовая инструкция. В этом случае ThrowingErrorListener должен сообщить о синтаксической ошибке (листинг 3.4)
\lstinputlisting[caption=Пример тестового сценария с синтаксической ошибкой, language=java,  firstline=1,  lastline=10 ]{res/ErrorExample.txt}


\lstinputlisting[caption=Результат работы интерпретатора для тестового сценария с синтаксической ошибкой, language=java,  firstline=13,  lastline=14]{res/ErrorExample.txt}


В случае, если на вход подается тестовая спецификация, в окторой указана инструкция, не объявленая в пользовательской библиотеке команд, возникает исключение UndefinedInstructionException, сообщающее какая именно инструкция была неопределена.

\lstinputlisting[caption=Пример тестового сценария необъявленной инструкцией, language=java,  firstline=18,  lastline=20 ]{res/ErrorExample.txt}


\lstinputlisting[caption=Результат работы интерпретатора для тестового сценария с необъявленной инструкцией, language=java,  firstline=22,  lastline=23]{res/ErrorExample.txt}



%TODO: add more info about defferent exceptions

\chapter{Экспериментальная часть }
\label{cExperiments}
%Рекомендуемый объем главы --- 5--20 стр.
%Название главы должно отражать ее содержание, например ``Оценка эффективности вечного двигателя''.



%\section{Тестирование}
%Проверка адекватности модели, сравнение с существующими аналогами, выбор 
%представительного множества тестов, анализ результатов испытаний.

Для тестирования реализованного языка были разработа Unit тесты. Модульное тестирование, оно же юнит-тестирование, позволяет проверить корректность отдельных модулей исходного кода программы. 

\lstinputlisting[caption=входные данные для теста testTwoInstructionsInTheSameLine, language=java,  firstline=2,  lastline=9 ]{res/testTwoInstructionsInTheSameLine.txt}

\lstinputlisting[caption=входные данные для теста testSetEmptyInstruction, language=java,  firstline=13,  lastline=22 ]{res/testTwoInstructionsInTheSameLine.txt}


Ниже представлена спецификация для разработанного синтаксического анализатора и результаты выполнения тестов


%
% Please add the following required packages to your document preamble:
% \usepackage{booktabs}
% \usepackage{graphicx}
\begin{table}[]
\resizebox{\textwidth}{!}{%
\begin{tabular}{@{}lllll@{}}
\begin{tabular}[c]{@{}l@{}}Входной\\ текст\end{tabular}                       & \begin{tabular}[c]{@{}l@{}}Ожидаемое\\ поведение\end{tabular} & Статус    &  &  \\
@Pause [erf] ms                                                               & line 1:8 mismatched input 'erf' expecting INTEGER             & выполнено &  &  \\
@Pause [] ms                                                                  & line 1:8 missing INTEGER at ']'                               & выполнено &  &  \\
\begin{tabular}[c]{@{}l@{}}@Pause [2] ms\\ @Pause [] ms\end{tabular}          & line 2:8 missing INTEGER at ']'                               & выполнено &  &  \\
\begin{tabular}[c]{@{}l@{}}@Pause [2] ms\\ @Send\end{tabular}                 & line 2:6 missing TEXT at '<EOF>'                              & выполнено &  &  \\
\begin{tabular}[c]{@{}l@{}}@Pause [2] ms \\ @Send  @Pause [2] ms\end{tabular} & line 2:6 mismatched input '@Pause' expecting TEXT             & выполнено &  & 
\end{tabular}%
}
\end{table}

В результате тестирования выявлено, что интерпретатор работает корректно.

%\section{Примеры применения метода или программы}

\Chapter{Заключение }
%Рекомендуемый объем --- 2--4 стр.
%Содержит изложение итогов квалификационной работы в сопоставлении с общей 
%целью и поставленными задачами. Формулировка суждения автора о научной 
%новизне и практической ценности ВКР. Предложения по внедрению результатов, 
%перспективы продолжения работы 



\bibliographystyle{gost71s}
%\bibliography{bibliography}                              


\end{document}